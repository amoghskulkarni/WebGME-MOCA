/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Mon Feb 01 2016 12:33:01 GMT-0600 (Central Standard Time).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'common/util/ejs',
    'common/util/xmljsonconverter',
    'plugin/MOCACodeGenerator/MOCACodeGenerator/Templates/Templates',
    'q'
], function (
    PluginConfig,
    PluginBase,
    ejs,
    Converter,
    TEMPLATES,
    Q) {
    'use strict';

    /**
     * Initializes a new instance of MOCACodeGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin MOCACodeGenerator.
     * @constructor
     */
    var MOCACodeGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.FILES = [
            {
                name: 'components',
                template: 'moca.components.generated.py.ejs'
            },
            {
                name: 'groups',
                template: 'moca.groups.generated.py.ejs'
            }
        ];
    };

    // Prototypal inheritance from PluginBase.
    MOCACodeGenerator.prototype = Object.create(PluginBase.prototype);
    MOCACodeGenerator.prototype.constructor = MOCACodeGenerator;

    /**
     * Gets the name of the MOCACodeGenerator.
     * @returns {string} The name of the plugin.
     * @public
     */
    MOCACodeGenerator.prototype.getName = function () {
        return 'MOCACodeGenerator';
    };

    /**
     * Gets the semantic version (semver.org) of the MOCACodeGenerator.
     * @returns {string} The version of the plugin.
     * @public
     */
    MOCACodeGenerator.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    MOCACodeGenerator.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject;
        nodeObject = self.activeNode;

        if (self.core.getParent(nodeObject) === null &&
            self.core.getAttribute(nodeObject, 'name') !== "ROOT") {
            callback(new Error('The plugin has to be executed from ROOT.'), self.result);
            return;
        }

        self.generateDataModel(nodeObject)
            .then(function (dataModel) {
                self.logger.info(JSON.stringify(dataModel, null, 4));
                return self.generateArtifact(dataModel);
            })
            .then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                self.logger.error(err);
                self.createMessage(null, err.message, 'error');
                self.result.setSuccess(false);
                callback(null, self.result);
            })
            .done();
    };


    MOCACodeGenerator.prototype.generateDataModel = function (rootNode) {
        var self = this,
            deferred = new Q.defer(),
            dataModel = {
                comps: [],
                groups: [],
                problems: [
                    // {
                    //     name:
                    //     driver:
                    //     comps: [],
                    //     groups: [],
                    //     desvars: [],
                    //     objectives: [],
                    //     records: []
                    // }
                ]
            };


        self.core.loadChildren(rootNode, function (err, children) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var componentPromises = [],
                groupPromises = [],
                problemPromises = [];

            for (var i = 0; i < children.length; i += 1) {
                if (self.core.getAttribute(self.getMetaType(children[i]), 'name') == 'Component')
                    componentPromises.push(self.getComponentData(children[i]));
                else if (self.core.getAttribute(self.getMetaType(children[i]), 'name') == 'Group')
                    groupPromises.push(self.getGroupData(children[i]));
                // else if (self.core.getAttribute(self.getMetaType(children[i]), 'name') == 'Problem')
                //     problemPromises.push(self.getProblemData(children[i]));
            }

            Q.all(componentPromises)
                .then(function (componentsData) {
                    dataModel.comps = componentsData;
                    Q.all(groupPromises)
                        .then(function (groupsData) {
                            dataModel.groups = groupsData;
                            Q.all(problemPromises)
                                .then(function (problemsData) {
                                    dataModel.problems = problemsData;
                                    deferred.resolve(dataModel);
                                })
                                .catch(deferred.reject);
                        })
                        .catch(deferred.reject);
                })
                .catch(deferred.reject);
        });

        return deferred.promise;
    };

    MOCACodeGenerator.prototype.getComponentData = function(componentNode) {
        var self = this,
            deferred = new Q.defer(),
            componentData = {
                name: self.core.getAttribute(componentNode, 'name'),
                type: self.core.getAttribute(componentNode, 'Type'),
                force_fd: self.core.getAttribute(componentNode, 'ForceFD'),
                parameters: [],
                unknowns: []
            };

        self.core.loadChildren(componentNode, function(err, children) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var parameterPromises = [],
                unknownPromises = [];

            for (var i = 0; i < children.length; i += 1) {
                if (self.core.getAttribute(self.getMetaType(children[i]), 'name') == 'Parameter')
                    parameterPromises.push(self.getParameterData(children[i]));
                else if (self.core.getAttribute(self.getMetaType(children[i]), 'name') == 'Unknown')
                    unknownPromises.push(self.getUnknownData(children[i]));
            }

            Q.all(parameterPromises)
                .then(function (parametersData) {
                    componentData.parameters = parametersData;
                    Q.all(unknownPromises)
                        .then(function (unknownsData) {
                            componentData.unknowns = unknownsData;
                            deferred.resolve(componentData);
                        })
                        .catch(deferred.reject);
                })
                .catch(deferred.reject);
        });

        return deferred.promise;
    }

    MOCACodeGenerator.prototype.getParameterData = function(parameterNode) {
        var self = this,
            deferred = new Q.defer(),
            parameterData = {
                name: self.core.getAttribute(parameterNode, 'name'),
                value: self.core.getAttribute(parameterNode, 'Value')
            },
            error,
            counter;

        deferred.resolve(parameterData);

        return deferred.promise;
    };


    MOCACodeGenerator.prototype.getUnknownData = function(unknownNode) {
        var self = this,
            deferred = new Q.defer(),
            unknownData = {
                name: self.core.getAttribute(unknownNode, 'name'),
                value: self.core.getAttribute(unknownNode, 'Value'),
                type: self.core.getAttribute(unknownNode, 'Type'),
            },
            error,
            counter;

        // // Load all connections going out from the node, i.e. has the node as 'src'.
        // self.core.loadCollection(unknownNode, 'src', function (err, connections) {
        //     if (err) {
        //         deferred.reject(new Error(err));
        //         return;
        //     }
        //     var counter = connections.length;
        //
        //     // For each connection load the destination state.
        //     for (var i = 0; i < connections.length; i += 1) {
        //         self.core.loadPointer(connections[i], 'dst', function (err, dstNode) {
        //             if (err) {
        //                 error = new Error(err);
        //             } else {
        //                 unknownData.connections.push({
        //                     targetName: self.core.getAttribute(dstNode, 'name')
        //                 });
        //             }
        //
        //             counter -= 1;
        //             if (counter === 0) {
        //                 if (error) {
        //                     deferred.reject(error);
        //                 } else {
        //                     deferred.resolve(unknownData);
        //                 }
        //             }
        //         });
        //     }
        //
        //     // Make sure to resolve when there are no connections.
        //     if (connections.length === 0) {
        //         deferred.resolve(unknownData);
        //     }
        // });
        deferred.resolve(unknownData);

        return deferred.promise;
    };


    MOCACodeGenerator.prototype.getGroupData = function(groupNode) {
        var self = this,
            deferred = new Q.defer(),
            groupData = {
                name: self.core.getAttribute(groupNode, 'name'),
                compInstances: [],
                groupInstances: [],
                connections: []
            };

        self.core.loadChildren(groupNode, function(err, children) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var compInstancePromises = [],
                groupInstancePromises = [],
                connectionPromises = [],
                promotePromises = [];

            for (var i = 0; i < children.length; i += 1) {
                if (self.core.getAttribute(self.getMetaType(children[i]), 'name') == 'Component')
                    compInstancePromises.push(self.getCompInstanceData(children[i]));
                else if (self.core.getAttribute(self.getMetaType(children[i]), 'name') == 'Group')
                    groupInstancePromises.push(self.getGroupInstanceData(children[i]));
                // TODO: get connections data
            }

            Q.all(compInstancePromises)
                .then(function (compInstancesData) {
                    groupData.compInstances = compInstancesData;
                    Q.all(groupInstancePromises)
                        .then(function (groupInstancesData) {
                            groupData.groupInstances = groupInstancesData;
                            // Q.all(promotePromises)
                            //     .then(function (promotesData) {
                            //         groupData.promotes = promotesData;
                                    deferred.resolve(groupData);
                                // })
                                // .catch(deferred.reject);
                        })
                        .catch(deferred.reject);
                })
                .catch(deferred.reject);
        });

        deferred.resolve(groupData);

        return deferred.promise;
    }

    MOCACodeGenerator.prototype.getCompInstanceData = function (compInstanceNode) {
        var self = this,
            deferred = Q.defer(),
            compInstancesData = {
                name: self.core.getAttribute(compInstanceNode, 'name'),
                base: self.core.getAttribute(self.core.getBase(compInstanceNode), 'name'),
                promotes: []
            };

        self.core.loadChildren(compInstanceNode, function(err, children) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }

            for (var i = 0; i < children.length; i++) {
                self.core.loadCollection(children[i], 'dst', function(err, connections) {
                    if (err) {
                        deferred.reject(new Error(err));
                        return;
                    }

                    for (var j = 0; j < connections.length; j++) {
                        if (self.core.getAttribute(connections[j], 'name') === 'PrToPortAssoc') {
                            self.core.loadPointer(connections[j], 'dst', function (err, dstNode) {
                                if (err) {
                                    error = new Error(err);
                                } else {
                                    compInstancesData.promotes.push(self.core.getAttribute(dstNode, 'name'));
                                }
                                deferred.resolve(compInstancesData);
                            });
                        }
                    }

                    if (connections.length == 0)
                        deferred.resolve(compInstancesData);
                });
            }

            if (children.length == 0)
                deferred.resolve(compInstancesData);
        });

        return deferred.promise
    };

    MOCACodeGenerator.prototype.getGroupInstanceData = function (groupInstanceNode) {
        var self = this,
            deferred = Q.defer(),
            groupInstancesData = {
                name: self.core.getAttribute(groupInstanceNode, 'name'),
                base: self.core.getAttribute(self.core.getBase(groupInstanceNode), 'name'),
                promotes: []
            };

        self.core.loadChildren(groupInstanceNode, function(err, children) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }

            for (var i = 0; i < children.length; i++) {
                self.core.loadCollection(children[i], 'dst', function(err, connections) {
                    if (err) {
                        deferred.reject(new Error(err));
                        return;
                    }

                    for (var j = 0; j < connections.length; j++) {
                        if (self.core.getAttribute(connections[j], 'name') === 'PrToPortAssoc') {
                            self.core.loadPointer(connections[j], 'dst', function (err, dstNode) {
                                if (err) {
                                    error = new Error(err);
                                } else {
                                    groupInstancesData.promotes.push(self.core.getAttribute(dstNode, 'name'));
                                }
                                deferred.resolve(groupInstancesData);
                            });
                        }
                    }

                    if (connections.length == 0)
                        deferred.resolve(groupInstancesData);
                });
            }

            if (children.length == 0)
                deferred.resolve(groupInstancesData);
        });

        return deferred.promise
    };


    // TODO: getConnectionsData()

    // TODO: Call these methods in getProblemData()
    // MOCACodeGenerator.prototype.getDesignVariableData = function(designvariableNode) {
    //     var self = this,
    //         deferred = new Q.defer(),
    //         designvariableData = {
    //             name: self.core.getAttribute(designvariableNode, 'name'),
    //             upper: self.core.getAttribute(designvariableNode, 'Upper'),
    //             lower: self.core.getAttribute(designvariableNode, 'Lower'),
    //             connections: [
    //                 // targetName: the name of the port that this unknown is connected to
    //                 // targetParentName: the name of the parent of the port that this unknown
    //                 //              is connected to
    //             ]
    //         },
    //         error,
    //         counter;
    //
    //     // Load all connections going out from the node, i.e. has the stateNode as 'src'.
    //     self.core.loadCollection(designvariableNode, 'src', function (err, connections) {
    //         if (err) {
    //             deferred.reject(new Error(err));
    //             return;
    //         }
    //         var i;
    //         counter = connections.length;
    //
    //         // For each connection load the destination node.
    //         for (i = 0; i < connections.length; i += 1) {
    //             self.core.loadPointer(connections[i], 'dst', function (err, dstNode) {
    //                 if (err) {
    //                     error = new Error(err);
    //                 } else {
    //                     designvariableData.connections.push({
    //                         targetName: self.core.getAttribute(dstNode, 'name')
    //                         // TODO: targetParentName
    //                     });
    //                 }
    //
    //                 counter -= 1;
    //                 if (counter === 0) {
    //                     if (error) {
    //                         deferred.reject(error);
    //                     } else {
    //                         deferred.resolve(designvariableData);
    //                     }
    //                 }
    //             });
    //         }
    //
    //         // Make sure to resolve when there are no connections.
    //         if (connections.length === 0) {
    //             deferred.resolve(designvariableData);
    //         }
    //     });
    //
    //     return deferred.promise;
    // };
    //
    // MOCACodeGenerator.prototype.getObjectiveData = function(objectiveNode) {
    //     var self = this,
    //         deferred = new Q.defer(),
    //         objectiveData = {
    //             name: self.core.getAttribute(objectiveNode, 'name'),
    //             connections: [
    //                 // sourceName: the name of the port that this unknown is connected to
    //                 // sourceParentName: the name of the parent of the port that this unknown
    //                 //              is connected to
    //             ]
    //         },
    //         error,
    //         counter;
    //
    //     // Load all connections coming in into the node, i.e. has the Node as 'dst'.
    //     self.core.loadCollection(objectiveNode, 'dst', function (err, connections) {
    //         if (err) {
    //             deferred.reject(new Error(err));
    //             return;
    //         }
    //         var i;
    //         counter = connections.length;
    //
    //         // For each connection load the src node.
    //         for (i = 0; i < connections.length; i += 1) {
    //             self.core.loadPointer(connections[i], 'src', function (err, srcNode) {
    //                 if (err) {
    //                     error = new Error(err);
    //                 } else {
    //                     objectiveData.connections.push({
    //                         sourceName: self.core.getAttribute(srcNode, 'name')
    //                         // TODO: sourceParentName
    //                     });
    //                 }
    //
    //                 counter -= 1;
    //                 if (counter === 0) {
    //                     if (error) {
    //                         deferred.reject(error);
    //                     } else {
    //                         deferred.resolve(objectiveData);
    //                     }
    //                 }
    //             });
    //         }
    //
    //         // Make sure to resolve when there are no connections.
    //         if (connections.length === 0) {
    //             deferred.resolve(objectiveData);
    //         }
    //     });
    //
    //     return deferred.promise;
    // };
    //
    // MOCACodeGenerator.prototype.getRecordData = function(recordNode) {
    //     var self = this,
    //         deferred = new Q.defer(),
    //         recordData = {
    //             name: self.core.getAttribute(designvariableNode, 'name')
    //         },
    //         error,
    //         counter;
    //
    //     deferred.resolve(objectiveData);
    //
    //     return deferred.promise;
    // };

    MOCACodeGenerator.prototype.generateArtifact = function (dataModel) {
        var self = this,
            filesToAdd = {},
            deferred = new Q.defer(),
            artifact = self.blobClient.createArtifact('MOCA');

        filesToAdd['MOCA.json'] = JSON.stringify(dataModel, null, 2);
        filesToAdd['MOCA_metadata.json'] = JSON.stringify({
            projectId: self.projectId,
            commitHash: self.commitHash,
            branchName: self.branchName,
            timeStamp: (new Date()).toISOString(),
            pluginVersion: self.getVersion()
        }, null, 2);

        // self.LANGUAGES.forEach(function (languageInfo) {
        //     self.addLanguageToFiles(filesToAdd, dataModel, languageInfo);
        // });

        self.addPythonSourceFiles(filesToAdd, dataModel);

        artifact.addFiles(filesToAdd, function (err) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }

                self.result.addArtifact(hashes[0]);
                deferred.resolve();
            });
        });

        return deferred.promise;
    };


    MOCACodeGenerator.prototype.addPythonSourceFiles = function (filesToAdd, dataModel) {
        // var genFileName = 'MOCA-GeneratedCode/' + dataModel.OpenMDAOProblem.name + '.' + languageInfo.fileExtension,
        //     batFileName = 'MOCA-GeneratedCode/' + dataModel.OpenMDAOProblem.name + '.bat';
        //
        // this.logger.debug(genFileName);
        // this.logger.debug(batFileName);
        //
        // filesToAdd[genFileName] = ejs.render(TEMPLATES[languageInfo.generated], dataModel);
        // filesToAdd[batFileName] = ejs.render(TEMPLATES[languageInfo.batFile], dataModel);

        var self = this;

        self.FILES.forEach(function (fileInfo) {
            if (fileInfo.name !== 'problem')
            {
                var genFileName = 'MOCA_GeneratedCode/' + fileInfo.name + '.py';
                self.logger.debug(genFileName);
                filesToAdd[genFileName] = ejs.render(TEMPLATES[fileInfo.template], dataModel);
            }

            // TODO: If the filename is "problem" - use the template for problems
            //      additionally generate .bat file for that as well
        });

        //TODO Add the static files too.
        self.logger.info('Generated python files for MOCA');
    };

    return MOCACodeGenerator;
});
