/* Generated file based on ejs templates */
define([], function() {
    return {
    "moca.components.generated.py.ejs": "#!/usr/bin/python\r\nfrom openmdao.api import Component\r\nfrom math import pi, sqrt\r\nimport sys\r\n\r\n<%\r\n// Generate the code the component\r\n-%>\r\nclass <%= name %>(Component):\r\n    def __init__(self):\r\n        super(<%= name %>, self).__init__()\r\n<%\r\n// Generate \"add_param\" statements\r\nfor (var j = 0; j < parameters.length; j++) {\r\n    valueString = parameters[j].value;\r\n    if (valueString.indexOf('.') === -1)\r\n        valueString += '.0';\r\n-%>\r\n        self.add_param('<%= parameters[j].name %>', val=<%= parameters[j].value %>)\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Generate \"add_output\" and \"add_state\" statements\r\nfor (var j = 0; j < unknowns.length; j++) {\r\n    var valueString = unknowns[j].value;\r\n    if (valueString.indexOf('.') === -1)\r\n        valueString += '.0';\r\n-%>\r\n        self.add_output('<%= unknowns[j].name %>', val=<%= unknowns[j].value %>)\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Generate statement configuring force_fd\r\nif (force_fd === true) {\r\n-%>\r\n        self.deriv_options['type'] = 'fd'\r\n<%\r\n}\r\n-%>\r\n\r\n    def solve_nonlinear(self, params, unknowns, resids):\r\n        # Assigning shorthand(s) to the parameter(s)\r\n<%\r\n// Generate statements for dummy implementation of the method\r\nfor (var j = 0; j < parameters.length; j++) {\r\n-%>\r\n        <%= parameters[j].name %> = params['<%= parameters[j].name %>']\r\n<%\r\n}\r\n-%>\r\n\r\n<%\r\n// Generate statements to give explicit equation between output(s) and input(s)\r\nif (outputFunction === '') {\r\n    // Print the dummy code snippet if the user hasn't given one\r\n    var dummyStatement = '';\r\n    for (var j = 0; j < parameters.length; j++) {\r\n        dummyStatement += parameters[j].name;\r\n        if (j != parameters.length - 1)\r\n            dummyStatement += ' + ';\r\n    }\r\n    for (var j = 0; j < unknowns.length; j++) {\r\n-%>\r\n        # Dummy function for the unknown <%= unknowns[j].name %>\r\n        <%= unknowns[j].name %> = <%= dummyStatement %>\r\n<%\r\n    }\r\n} else {\r\n-%>\r\n        # This code snippet is defined by user using the embedded code editor in MOCA\r\n<%\r\n    // Print the user defined code snippet\r\n    var eqnLines = outputFunction.split(\"\\n\");\r\n    for (var j = 0; j < eqnLines.length; j++) {\r\n        if (eqnLines[j] !== '') {\r\n-%>\r\n        <%- eqnLines[j] %>\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n\r\n        # Assign the value(s) to unknown(s)\r\n<%\r\nfor (var j = 0; j < unknowns.length; j++) {\r\n-%>\r\n        unknowns['<%= unknowns[j].name %>'] = <%= unknowns[j].name %>\r\n<%\r\n}\r\n-%>\r\n<%\r\n// If the component is implicit, generate code for apply_nonlinear()\r\nif (type === 'Implicit') {\r\n    // TODO: Generate statements giving the values for residuals\r\n-%>\r\n\r\n    def apply_nonlinear(self, params, unknowns, resids):\r\n        print \"Provide the values of the residuals in apply_nonlinear() for <%= comps[i].name %>\"\r\n<%\r\n}\r\n-%>\r\n<%\r\n// If the force_fd is set to false, generate code for linearize()\r\nif (force_fd === false) {\r\n-%>\r\n\r\n    def linearize(self, params, unknowns, resids):\r\n        J = {}\r\n\r\n        # Assigning shorthand(s) to the parameter(s)\r\n<%\r\n    // Generate statements for dummy implementation of the method\r\n    for (var j = 0; j < parameters.length; j++) {\r\n-%>\r\n        <%= parameters[j].name %> = params['<%= parameters[j].name %>']\r\n<%\r\n    }\r\n-%>\r\n\r\n        # This jecobian is defined by user using the embedded code editor in MOCA\r\n<%\r\n    // Print the user defined code snippet\r\n    var jecobianLines = jacobian.split(\"\\n\");\r\n    for (var j = 0; j < jecobianLines.length; j++) {\r\n        if (jecobianLines[j] !== '') {\r\n-%>\r\n        <%- jecobianLines[j] %>\r\n<%\r\n        }\r\n    }\r\n-%>\r\n\r\n        # Return Jacobian (should not be empty)\r\n        return J\r\n<%\r\n}\r\n-%>\r\n",
    "moca.datasources.generated.py.ejs": "#!/usr/bin/python\r\nfrom influxdb import InfluxDBClient\r\n\r\n<%\r\nvar query_params_list = [],\r\n    query_params_names_list = \"\",\r\n    query_results_list = [];\r\nfor (var i = 0; i < children.length; i++) {\r\n    if (children[i].meta !== 'QueryResultGroups'\r\n        && children[i].meta !== 'QueryResultTime'\r\n        && children[i].meta !== 'QueryResultValue') {\r\n        query_params_list.push(children[i]);\r\n    } else {\r\n        query_results_list.push(children[i]);\r\n    }\r\n}\r\nfor (var i = 0; i < query_params_list.length; i++) {\r\n    query_params_names_list += query_params_list[i].name;\r\n    if (i < query_params_list.length - 1) {\r\n        query_params_names_list += \", \";\r\n    }\r\n}\r\nforEachTag = '\\'' + forEachTag + '\\''\r\noperationOnMeasurement = '\\'' + operationOnMeasurement + '\\''\r\nvariableNameInDB = '\\'' + variableNameInDB + '\\''\r\nif (tags === '')\r\n    tags = '\\'\\''\r\nif (tEnd === '')\r\n    tEnd = '\\'\\''\r\nif (tStart === '')\r\n    tStart = '\\'\\''\r\nif (value === '')\r\n    value = '\\'\\''\r\n-%>\r\n\r\ndef sanity_check(param_list):\r\n    # TODO: Add the logic to check if the parameters to this methods are of equal dimensions\r\n    # TODO: Implement the method with variable arguments signature\r\n    return True\r\n\r\nclass <%= name %>():\r\n    def __init__(self, <%= query_params_names_list %>):\r\n        # Query parameters\r\n        self.query_params = {}\r\n        self.query_params['for_each'] = <%- forEachTag %>\r\n        self.query_params['operation'] = <%- operationOnMeasurement %>\r\n        self.query_params['measurement'] = <%- variableNameInDB %>\r\n<%\r\nvar p_tags = false,\r\n    p_tEnd = false,\r\n    p_tStart = false,\r\n    p_value = false;\r\nfor (var i = 0; i < query_params_list.length; i++) {\r\n    if (query_params_list[i].meta === 'QueryParamTags') {\r\n-%>\r\n        self.query_params['tags'] = <%= query_params_list[i].name %>\r\n<%\r\n        p_tags = true;\r\n    } else if (query_params_list[i].meta === 'QueryParamTEnd') {\r\n-%>\r\n        self.query_params['t_end'] = <%= query_params_list[i].name %>\r\n<%\r\n        p_tEnd = true;\r\n    } else if (query_params_list[i].meta === 'QueryParamTStart') {\r\n-%>\r\n        self.query_params['t_start'] = <%= query_params_list[i].name %>\r\n<%\r\n        p_tStart = true;\r\n    } else if (query_params_list[i].meta === 'QueryParamValue') {\r\n-%>\r\n        self.query_params['value'] = <%= query_params_list[i].name %>\r\n<%\r\n        p_value = true;\r\n    }\r\n}\r\n\r\nif (!p_tags) {\r\n-%>\r\n        self.query_params['tags'] = <%- tags %>\r\n<%\r\n}\r\nif (!p_tEnd) {\r\n-%>\r\n        self.query_params['t_end'] = <%- tEnd %>\r\n<%\r\n}\r\nif (!p_tStart) {\r\n-%>\r\n        self.query_params['t_start'] = <%- tStart %>\r\n<%\r\n}\r\nif (!p_value) {\r\n-%>\r\n        self.query_params['value'] = <%- value %>\r\n<%\r\n}\r\n-%>\r\n\r\n        # Query results\r\n        self.query_results = {}\r\n<%\r\nfor (var i = 0; i < query_results_list.length; i++) {\r\n-%>\r\n        self.query_results['<%= query_results_list[i].name %>'] = []\r\n<%\r\n}\r\n-%>\r\n\r\n        # InfluxDB client\r\n        self.client = InfluxDBClient(host='<%= databaseRef[0].dbHost %>', port=<%= databaseRef[0].dbPortNo %>, database='<%= databaseRef[0].dbName %>')\r\n\r\n    def __build_query_string(self, query_n=None):\r\n<%\r\n    var valueString = 'value';\r\n    var stringInResult = 'value';\r\n    if (operationOnMeasurement === '\\'Integral\\'') {\r\n        valueString = 'INTEGRAL(value)';\r\n        stringInResult = 'integral';\r\n    }\r\n-%>\r\n        query_string = 'SELECT <%= valueString %> FROM {0}'.format(self.query_params['measurement'])\r\n        where_clause = ''\r\n        group_by_clause = ''\r\n\r\n        # Extract t_start, t_end, values, tags, group_by, operation\r\n        # TODO: Use value filter in WHERE clause\r\n        if query_n is None:\r\n            # Single query\r\n            if self.query_params['t_start'] is not '' and self.query_params['t_end'] is not '':\r\n                where_clause += ' WHERE ('\r\n                for t_s, t_e in zip(self.query_params['t_start'], self.query_params['t_end']):\r\n                    where_clause += '(\"time\" > \\'{0}\\' AND \"time\" < \\'{1}\\') OR'.format(t_s, t_e)\r\n                where_clause = where_clause[:-3]                # To remove trailing OR\r\n                where_clause += ')'\r\n            if self.query_params['tags'] is not '':\r\n                if where_clause is '':\r\n                    where_clause += ' WHERE ('\r\n                else:\r\n                    where_clause += 'AND ('\r\n                for tag_key, tag_value in self.query_params['tags'].items():\r\n                    where_clause += '(\"{0}\"=\\'{1}\\') AND'.format(tag_key, tag_value)\r\n                where_clause = where_clause[:-4]                # To remove trailing AND\r\n                where_clause += ')'\r\n            if self.query_params['for_each'] is not '':\r\n                group_by_clause += ' GROUP BY {0}'.format(self.query_params['for_each'])\r\n            query_string += '{0}{1}'.format(where_clause, group_by_clause)\r\n        else:\r\n            # Multiple queries\r\n            if self.query_params['t_start'] is not '' and self.query_params['t_end'] is not '':\r\n                where_clause += ' WHERE '\r\n                t_s = self.query_params['t_start'][query_n]\r\n                t_e = self.query_params['t_end'][query_n]\r\n                where_clause += '(\"time\" > \\'{0}\\' AND \"time\" < \\'{1}\\')'.format(t_s, t_e)\r\n            if self.query_params['tags'] is not '':\r\n                if where_clause is '':\r\n                    where_clause += ' WHERE ('\r\n                else:\r\n                    where_clause += ' AND ('\r\n                for tag_key, tag_value in self.query_params['tags'][query_n].items():\r\n                    where_clause += '\"{0}\"=\\'{1}\\' AND '.format(tag_key, tag_value)\r\n                where_clause = where_clause[:-5]                # To remove trailing AND\r\n                where_clause += ')'\r\n            query_string += '{0}'.format(where_clause)\r\n\r\n        return query_string\r\n\r\n    def execute_query(self):\r\n        query_result_groups = []\r\n        query_result_times = []\r\n        query_result_values = []\r\n\r\n        # TODO: Check shape and raise error if the shapes mismatch\r\n\r\n        # Here we are assuming that the shapes of t_start, t_end, values and tags are the same\r\n        # (i.e. if they have a non-zero value flowing/hardcoded inside them)\r\n        params_are_list = False\r\n        if type(self.query_params['tags']) == list:\r\n            params_are_list = True\r\n\r\n        if not params_are_list:\r\n            # This is a 1D array or t_start='', only 1 query is fired\r\n            query_string = self.__build_query_string()\r\n            print \"Query: \" + query_string\r\n            query_result = self.client.query(query=query_string)\r\n\r\n            # If it is a GROUP BY query\r\n            if query_result.keys()[0][1] is not None:\r\n                for query_group_key, query_group_value in query_result.items():\r\n                    query_result_groups.append(query_group_key[1])\r\n                    query_result_times_for_this_group = []\r\n                    query_result_values_for_this_group = []\r\n                    for v in query_group_value:\r\n                        query_result_times_for_this_group.append(v['time'])\r\n                        query_result_values_for_this_group.append(v['<%= stringInResult %>'])\r\n                    query_result_times.append(query_result_times_for_this_group)\r\n                    query_result_values.append(query_result_values_for_this_group)\r\n            else:\r\n                for v in query_result[query_result.keys()[0]]:\r\n                    query_result_times.append(v['time'])\r\n                    query_result_values.append(v['<%= stringInResult %>'])\r\n\r\n        else:\r\n            # This is a 2D array, multiple queries are fired\r\n            for query_n in range(len(self.query_params['tags'])):\r\n                query_string = self.__build_query_string(query_n)\r\n                print \"Query: \" + query_string\r\n                query_result = self.client.query(query=query_string)\r\n\r\n                this_query_result_times = []\r\n                this_query_result_values = []\r\n\r\n                for v in query_result[query_result.keys()[0]]:\r\n                    this_query_result_times.append(v['time'])\r\n                    this_query_result_values.append(v['<%= stringInResult %>'])\r\n\r\n                query_result_times.append(this_query_result_times)\r\n                query_result_values.append(this_query_result_values)\r\n\r\n<%\r\nfor (var i = 0; i < query_results_list.length; i++) {\r\n    var variableName = '';\r\n    if (query_results_list[i].meta === 'QueryResultGroups')\r\n        variableName = 'query_result_groups';\r\n    else if (query_results_list[i].meta === 'QueryResultTime')\r\n        variableName = 'query_result_times';\r\n    else if (query_results_list[i].meta === 'QueryResultValue')\r\n        variableName = 'query_result_values'\r\n-%>\r\n        self.query_results['<%= query_results_list[i].name %>'] = <%= variableName %>\r\n<%\r\n}\r\n-%>\r\n",
    "moca.ddcomp.generated.ipynb.ejs": "{\r\n    \"cells\": [\r\n        {\r\n            \"cell_type\": \"markdown\",\r\n            \"metadata\": {},\r\n            \"source\": [\r\n                \"# <%= name %> Data-Driven Component Training Notebook\\n\",\r\n                \"***\",\r\n                \"\\n\",\r\n                \"## Module imports\\n\",\r\n                \"\\n\"\r\n            ]\r\n        }\r\n        ,{\r\n            \"cell_type\": \"code\",\r\n            \"execution_count\": null,\r\n            \"metadata\": {\r\n                \"collapsed\": true\r\n            },\r\n            \"outputs\": [],\r\n            \"source\": [\r\n                \"%matplotlib inline\"\r\n<%\r\n    for (var i = 0; i < dataSources.length; i++) {\r\n-%>\r\n                ,\"\\n\"\r\n                ,\"from data_sources.<%= dataSources[i].name %> import <%= dataSources[i].name %>\"\r\n<%\r\n    }\r\n    for (var i = 0; i < dataPreprocs.length; i++) {\r\n-%>\r\n                ,\"\\n\"\r\n                ,\"from preprocs.<%= dataPreprocs[i].name %> import <%= dataPreprocs[i].name %>\"\r\n<%\r\n    }\r\n    for (var i = 0; i < learningAlgorithms.length; i++) {\r\n-%>\r\n                ,\"\\n\"\r\n                ,\"from learning_algos.<%= learningAlgorithms[i].name %> import <%= learningAlgorithms[i].name %>\"\r\n<%\r\n    }\r\n-%>\r\n            ]\r\n        }\r\n        ,{\r\n            \"cell_type\": \"markdown\",\r\n            \"metadata\": {},\r\n            \"source\": [\r\n                \"## Data Sources (Database querying)\\n\"\r\n            ]\r\n        }\r\n<%\r\n    for (var i = 0; i < dataSources.length; i++) {\r\n        var constructor_params = '',\r\n            dataSourceName = dataSources[i].name;\r\n        for (var j = 0; j < dataSources[i].children.length; j++) {\r\n            var childMetaType = dataSources[i].children[j].meta,\r\n                childName = dataSources[i].children[j].name;\r\n            if (childMetaType === 'QueryParamTags' || childMetaType === 'QueryParamTEnd'\r\n                    || childMetaType === 'QueryParamTStart' || childMetaType === 'QueryParamValue') {\r\n                constructor_params += (childName + '=');\r\n                for (var k = 0; k < connections.length; k++) {\r\n                    if (connections[k].dst === childName && connections[k].dstParent === dataSourceName) {\r\n                        if (connections[k].srcParentMeta === 'DataSource') {\r\n                            constructor_params += (connections[k].srcParent + '__inst.query_results[\\'' + connections[k].src + '\\'],');\r\n                        } else if (connections[k].srcParentMeta === 'DataPreprocessor') {\r\n                            constructor_params += (connections[k].srcParent + '__inst.' + connections[k].src + ',');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n-%>\r\n        ,{\r\n            \"cell_type\": \"code\",\r\n            \"execution_count\": null,\r\n            \"metadata\": {\r\n            \"collapsed\": true\r\n            },\r\n            \"outputs\": [],\r\n            \"source\": [\r\n                \"<%- dataSourceName %>__inst = <%- dataSourceName %>(<%- constructor_params %>)\"\r\n                ,\"\\n\"\r\n                ,\"<%- dataSourceName %>__inst.execute_query()\"\r\n            ]\r\n        }\r\n<%\r\n    }\r\n-%>\r\n        ,{\r\n            \"cell_type\": \"markdown\",\r\n            \"metadata\": {},\r\n            \"source\": [\r\n                \"## Preprocessors\\n\"\r\n            ]\r\n        }\r\n<%\r\n    for (var i = 0; i < dataPreprocs.length; i++) {\r\n        var constructor_params = '',\r\n            dataPreprocName = dataPreprocs[i].name;\r\n        for (var j = 0; j < dataPreprocs[i].inputPorts.length; j++) {\r\n            var inputPortName = dataPreprocs[i].inputPorts[j].name;\r\n            constructor_params += (inputPortName + '=');\r\n            for (var k = 0; k < connections.length; k++) {\r\n                if (connections[k].dst === inputPortName && connections[k].dstParent === dataPreprocName) {\r\n                    if (connections[k].srcParentMeta === 'DataSource') {\r\n                        constructor_params += (connections[k].srcParent + '__inst.query_results[\\'' + connections[k].src + '\\'],');\r\n                    } else if (connections[k].srcParentMeta === 'DataPreprocessor') {\r\n                        constructor_params += (connections[k].srcParent + '__inst.' + connections[k].src + ',');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n-%>\r\n        ,{\r\n            \"cell_type\": \"code\",\r\n            \"execution_count\": null,\r\n            \"metadata\": {\r\n                \"collapsed\": true\r\n            },\r\n            \"outputs\": [],\r\n            \"source\": [\r\n                \"<%= dataPreprocName %>__inst = <%= dataPreprocName %>(<%- constructor_params %>)\"\r\n                ,\"\\n\"\r\n                ,\"<%= dataPreprocName %>__inst.apply_preprocessing()\"\r\n            ]\r\n        }\r\n<%\r\n}\r\n-%>\r\n        ,{\r\n            \"cell_type\": \"markdown\",\r\n            \"metadata\": {},\r\n            \"source\": [\r\n                \"## Learning Algorithms (Model training)\\n\"\r\n            ]\r\n        }\r\n<%\r\n    for (var i = 0; i < learningAlgorithms.length; i++) {\r\n        var constructor_params = '',\r\n            learningAlgoName = learningAlgorithms[i].name;\r\n        for (var j = 0; j < learningAlgorithms[i].featurePorts.length; j++) {\r\n            var featurePortName = learningAlgorithms[i].featurePorts[j].name;\r\n            constructor_params += (featurePortName + '=');\r\n            for (var k = 0; k < connections.length; k++) {\r\n                if (connections[k].dst === featurePortName && connections[k].dstParent === learningAlgoName) {\r\n                    if (connections[k].srcParentMeta === 'DataSource') {\r\n                        constructor_params += (connections[k].srcParent + '__inst.query_results[\\'' + connections[k].src + '\\'],');\r\n                    } else if (connections[k].srcParentMeta === 'DataPreprocessor') {\r\n                        constructor_params += (connections[k].srcParent + '__inst.' + connections[k].src + ',');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (var j = 0; j < learningAlgorithms[i].labelPorts.length; j++) {\r\n            var labelPortName = learningAlgorithms[i].labelPorts[j].name;\r\n            constructor_params += (labelPortName + '=');\r\n            for (var k = 0; k < connections.length; k++) {\r\n                if (connections[k].dst === labelPortName && connections[k].dstParent === learningAlgoName) {\r\n                    if (connections[k].srcParentMeta === 'DataSource') {\r\n                        constructor_params += (connections[k].srcParent + '__inst.query_results[\\'' + connections[k].src + '\\'],');\r\n                    } else if (connections[k].srcParentMeta === 'DataPreprocessor') {\r\n                        constructor_params += (connections[k].srcParent + '__inst.' + connections[k].src + ',');\r\n                    }\r\n                }\r\n            }\r\n        }\r\n-%>\r\n        ,{\r\n            \"cell_type\": \"code\",\r\n            \"execution_count\": null,\r\n            \"metadata\": {\r\n            \"collapsed\": true\r\n            },\r\n            \"outputs\": [],\r\n            \"source\": [\r\n                \"<%- learningAlgoName %>__inst = <%- learningAlgoName %>(<%- constructor_params %>)\"\r\n                ,\"\\n\"\r\n                ,\"<%- learningAlgoName %>__inst.train()\"\r\n                ,\"\\n\"\r\n                ,\"<%- learningAlgoName %>__inst.predict()\"\r\n            ]\r\n        }\r\n<%\r\n}\r\n-%>\r\n    ],\r\n    \"metadata\": {\r\n        \"kernelspec\": {\r\n            \"display_name\": \"Python 2\",\r\n            \"language\": \"python\",\r\n            \"name\": \"python2\"\r\n        },\r\n        \"language_info\": {\r\n            \"codemirror_mode\": {\r\n                \"name\": \"ipython\",\r\n                \"version\": 2\r\n            },\r\n            \"file_extension\": \".py\",\r\n            \"mimetype\": \"text/x-python\",\r\n            \"name\": \"python\",\r\n            \"nbconvert_exporter\": \"python\",\r\n            \"pygments_lexer\": \"ipython2\",\r\n            \"version\": \"2.7.9\"\r\n        }\r\n    },\r\n    \"nbformat\": 4,\r\n    \"nbformat_minor\": 0\r\n}",
    "moca.ddcomponents.generated.py.ejs": "#!/usr/bin/python\r\nfrom openmdao.api import Component\r\nfrom sklearn.externals import joblib\r\n\r\n<%\r\n// Generate the code the component\r\n-%>\r\nclass <%= name %>(Component):\r\n    def __init__(self):\r\n        super(<%= name %>, self).__init__()\r\n<%\r\n// Generate \"add_param\" statements\r\nfor (var j = 0; j < parameters.length; j++) {\r\n    valueString = parameters[j].value;\r\n    if (valueString.indexOf('.') === -1)\r\n        valueString += '.0';\r\n-%>\r\n        self.add_param('<%= parameters[j].name %>', val=<%= parameters[j].value %>)\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Generate \"add_output\" and \"add_state\" statements\r\nfor (var j = 0; j < unknowns.length; j++) {\r\n    var valueString = unknowns[j].value;\r\n    if (valueString.indexOf('.') === -1)\r\n        valueString += '.0';\r\n-%>\r\n        self.add_output('<%= unknowns[j].name %>', val=<%= unknowns[j].value %>)\r\n<%\r\n}\r\n-%>\r\n\r\n        self.deriv_options['type'] = 'fd'\r\n\r\n        # Load the learned model using joblib dump\r\n        pickled_object = joblib.load('lib/moca_ddmodels/<%= name %>/<%= learnedModel %>.pkl')\r\n        self.features_list = pickled_object['features_list']\r\n        self.learned_model = pickled_object['model']\r\n\r\n    def solve_nonlinear(self, params, unknowns, resids):\r\n        ## Feed the **vector** of parameters to the learned model\r\n        [[<%= unknowns[0].name %>]] = self.learned_model.predict(X=[[params[feature_key] for feature_key in self.features_list]])\r\n\r\n        # Assign the value(s) to unknown(s)\r\n        unknowns['<%= unknowns[0].name %>'] = <%= unknowns[0].name %>\r\n",
    "moca.groups.generated.py.ejs": "#!/usr/bin/python\r\n\r\n# Static imports\r\nfrom openmdao.api import Group\r\n<%\r\n// Generate import statement for every component instance\r\nfor (var i = 0; i < compInstances.length; i++) {\r\n-%>\r\nfrom ..moca_components.<%= compInstances[i].base %> import <%= compInstances[i].base %>\r\n<%\r\n}\r\n-%>\r\nimport sys\r\n\r\n# Dynamic imports\r\n<%\r\nvar algebraicLoopImport = false;\r\nif (algebraicLoop && !algebraicLoopImport) {\r\n    algebraicLoopImport = true;\r\n-%>\r\nfrom openmdao.api import NLGaussSeidel, ScipyGMRES\r\n<%\r\n}\r\n-%>\r\n\r\n<%\r\n// Generate the code for the group\r\nvar promotedPorts = [];\r\n-%>\r\nclass <%= name %>(Group):\r\n    def __init__(self):\r\n        super(<%= name %>, self).__init__()\r\n\r\n<%\r\n// Generate the code for add() statements for components -\r\n// add instances of components\r\nfor (var j = 0; j < compInstances.length; j++) {\r\n    promotesString = '';\r\n    for (var k = 0; k < compInstances[j].promotes.length; k++) {\r\n        promotesString += \"'\" + compInstances[j].promotes[k] + \"'\";\r\n        promotedPorts.push(compInstances[j].name + \".\" + compInstances[j].promotes[k]);\r\n        if (k != compInstances[j].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= compInstances[j].name %>', <%= compInstances[j].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n}\r\n-%>\r\n\r\n<%\r\n// Generate the code for add() statements for groups -\r\n// add instances of groups\r\nfor (var j = 0; j < groupInstances.length; j++) {\r\n    var promotesString = '';\r\n    for (var k = 0; k < groupInstances[j].promotes.length; k++) {\r\n        promotesString += \"'\" + groupInstances[j].promotes[k] + \"'\";\r\n        promotedPorts.push(groupInstances[j].name + \".\" + groupInstances[j].promotes[k]);\r\n        if (k != groupInstances[j].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= groupInstances[j].name %>', <%= groupInstances[j].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n}\r\n-%>\r\n\r\n<%\r\n// Generate the code for connect() statements for connections between ports\r\nfor (var j = 0; j < connections.length; j++) {\r\n    var srcConnectString = connections[j].srcParent + \".\" + connections[j].src;\r\n    var dstConnectString = connections[j].dstParent + \".\" + connections[j].dst;\r\n    // Check whether these strings are in promotedPorts list, i.e. whether these ports are connected\r\n    if (promotedPorts.indexOf(srcConnectString) != -1)\r\n        srcConnectString = srcConnectString.split('.')[1];\r\n    if (promotedPorts.indexOf(dstConnectString) != -1)\r\n        dstConnectString = dstConnectString.split('.')[1];\r\n-%>\r\n        self.connect('<%= srcConnectString %>', '<%= dstConnectString %>')\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Change nl_solver and ln_driver in case of algebraic loop\r\nif (algebraicLoop) {\r\n-%>\r\n\r\n        # Special solvers for handling algebraic loops\r\n        self.nl_solver = NLGaussSeidel()\r\n        self.nl_solver.options['atol'] = 1.0e-12\r\n        self.ln_solver = ScipyGMRES()\r\n<%\r\n}\r\n-%>\r\n",
    "moca.learningalgo.generated.py.ejs": "#!/usr/bin/python\r\nfrom sklearn.model_selection import train_test_split\r\nfrom sklearn import linear_model\r\nfrom sklearn.metrics import mean_squared_error, r2_score\r\nfrom sklearn.externals import joblib\r\n\r\nimport numpy as np\r\nfrom math import sqrt\r\nfrom matplotlib import pyplot as plt\r\nfrom time import time\r\n\r\n<%\r\n    var featureString = '';\r\n    for (var i = 0; i < featurePorts.length; i++) {\r\n        featureString += featurePorts[i].name\r\n        if (i < featurePorts.length - 1) {\r\n            featureString += ', ';\r\n        }\r\n    }\r\n    if (featureString !== '') {\r\n        featureString = ', ' + featureString;\r\n    }\r\n\r\n    var labelString = '';\r\n    for (i = 0; i < labelPorts.length; i++) {\r\n        labelString += labelPorts[i].name\r\n        if (i < labelPorts.length - 1) {\r\n            labelString += ', ';\r\n        }\r\n    }\r\n    if (labelString !== '') {\r\n        labelString = ', ' + labelString;\r\n    }\r\n-%>\r\n\r\nclass <%= name %>():\r\n    def __init__(self<%= featureString %><%= labelString %>):\r\n        # TODO: Sanity check -- Check whether the features which are being passed are equal in length\r\n\r\n        # Get features\r\n        self.features = {}\r\n<%\r\n    for (i = 0; i < featurePorts.length; i++) {\r\n-%>\r\n        self.features['<%= featurePorts[i].name %>'] = <%= featurePorts[i].name %>\r\n<%\r\n    }\r\n-%>\r\n\r\n        # Get the order of the features (since the order in which parameters are passed to the regression algorithm\r\n        # matters while using it to predict the label)\r\n        self.features_list = self.features.keys()\r\n\r\n        # Get labels\r\n        self.labels = {}\r\n<%\r\n    for (i = 0; i < labelPorts.length; i++) {\r\n-%>\r\n        self.labels['<%= labelPorts[i].name %>'] = <%= labelPorts[i].name %>\r\n<%\r\n}\r\n-%>\r\n\r\n        # Training and testing datasets\r\n        self.X_train = None\r\n        self.X_test = None\r\n        self.y_train = None\r\n        self.y_test = None\r\n\r\n        # Placeholder: List for the trained models\r\n        self.trained_model = None\r\n\r\n    def train(self):\r\n        np.random.seed()\r\n\r\n        in_values = []\r\n        out_values = []\r\n\r\n        for data_point in range(len(self.features.values()[0])):\r\n            feature_vector = [self.features[key][data_point] for key in self.features_list]\r\n            label_vector = [self.labels[key][data_point] for key in self.labels]\r\n            in_values += feature_vector\r\n            out_values += label_vector\r\n\r\n        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(in_values, out_values, test_size=0.1)\r\n\r\n        unique_id_for_model = ''\r\n<%\r\n    // TODO: add other algorithms\r\n    if (algorithm === 'Linear') {\r\n-%>\r\n        self.trained_model = linear_model.LinearRegression()\r\n        self.trained_model.fit(self.X_train, self.y_train)\r\n<%\r\n    }\r\n-%>\r\n        if self.trained_model is not None:\r\n            unique_id_for_model = '<%= name %>_' + str(int(time() * 1000000))\r\n            joblib.dump({'features_list': self.features_list, 'model': self.trained_model}, unique_id_for_model + '.pkl')\r\n\r\n            print \"Trained model \" + unique_id_for_model + \" saved.\"\r\n        else:\r\n            print \"Model not trained.\"\r\n\r\n    def predict(self):\r\n        y_pred = self.trained_model.predict(X=self.X_test)\r\n        print \"y_act: \", self.y_test\r\n        print \"y_pred: \", y_pred\r\n\r\n        print(\"RMS error: %.2f\" % sqrt(mean_squared_error(self.y_test, y_pred)))\r\n        print('Variance score: %.2f' % r2_score(self.y_test, y_pred))\r\n\r\n        fig = plt.figure()\r\n        plt.plot(self.X_train, self.y_train, 'g^', markersize=5, label=u'Training data')\r\n        plt.plot(self.X_test, self.y_test, 'b.', markersize=5, label=u'Testing data')\r\n        plt.plot(self.X_test, y_pred, 'r.', markersize=5, label=u'Predictions')\r\n        plt.show()\r\n",
    "moca.parseutils.generated.py.ejs": "__author__ = 'Amogh'\r\n__doc__ = 'The utility class defined in this file gives the methods to access the sqlite database file' \\\r\n          'saved by OpenMDAO sqlite driver.'\r\n\r\nfrom sqlitedict import SqliteDict\r\n\r\nclass SqliteParseUtils:\r\n    def __init__(self, top):\r\n        # Get the database filename.\r\n        self.filename = top.driver.recorders._recorders[2].out_iterations.filename\r\n\r\n        # Wait for analysis to finish.\r\n        top.cleanup()\r\n\r\n    def __getValues(self, vartype, name):\r\n        values = []\r\n        db = SqliteDict(self.filename, 'iterations')\r\n        keylist = db.keys()\r\n        for key in keylist:\r\n            if key != 'metadata':\r\n                data = db[key]\r\n                if vartype != 'timestamp':\r\n                    values.append(data[vartype][name])\r\n                else:\r\n                    values.append(data[vartype])\r\n        return values\r\n\r\n    def getParamValues(self, paramname):\r\n        return self.__getValues('Parameters', paramname)\r\n\r\n    def getUnknownValues(self, unknownname):\r\n        return self.__getValues('Unknowns', unknownname)\r\n\r\n    def getTimestampValues(self):\r\n        return self.__getValues('timestamp', None)\r\n\r\nclass ResultsAccessUtils:\r\n    def __init__(self):\r\n        pass\r\n    def get_result_files(self, problem_name):\r\n        from IPython.display import FileLinks\r\n        return FileLinks('./out/text/' + problem_name + '/')\r\n",
    "moca.plotutils.generated.py.ejs": "__author__ = 'Amogh'\r\n__doc__ = 'The utility class defined in this file gives the methods to plot' \\\r\n          'the data points saved in the list on 2D and 3D plots.'\r\n\r\nfrom bokeh.models import HoverTool\r\nfrom bokeh.plotting import figure\r\nfrom bokeh.io import show, output_notebook, push_notebook\r\n\r\nfrom pandas import DataFrame\r\nfrom numpy import isclose\r\n\r\nfrom copy import deepcopy\r\n\r\nfrom ipywidgets import interact\r\nimport ipywidgets as widgets\r\n\r\n<%\r\nif (driver === 'FullFactorialDOE') {\r\n-%>\r\n\r\nclass <%= name %>_PlotUtils:\r\n    def __init__(self, parseutils):\r\n        timestamps = parseutils.getTimestampValues()\r\n<%\r\n    // generate __values statements for all the records connected to Unknowns only\r\n    for (var j = 0; j < records.length; j++) {\r\n        if (records[j].type === \"Unknown\") {\r\n-%>\r\n        <%= records[j].connection[0].srcParent %>_<%= records[j].connection[0].src %>__values = parseutils.getUnknownValues('<%= records[j].connection[0].srcParent %>.<%= records[j].connection[0].src %>')\r\n<%\r\n        }\r\n    }\r\n    // generate __values statements for all the desvars\r\n    // all desvars are recorded by default, and we access their values by taking the values of IndepVarComps\r\n    // Since, all IndepVarComps' outputs are Unknowns, we are using getUnknownValues\r\n    for (var j = 0; j < desvars.length; j++) {\r\n-%>\r\n        <%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__values = parseutils.getUnknownValues('<%= desvars[j].name %>.<%= desvars[j].connection[0].dst %>')\r\n<%\r\n    }\r\n-%>\r\n\r\n        # Dataframe construction\r\n        self.df = DataFrame({'timestamps': timestamps,\r\n<%\r\n    for (var j = 0; j < desvars.length; j++) {\r\n-%>\r\n                             '<%= desvars[j].connection[0].dstParent %>.<%= desvars[j].connection[0].dst %>': <%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__values,\r\n<%\r\n    }\r\n    for (var j = 0; j < records.length-1; j++) {\r\n        if (records[j].type === \"Unknown\") {\r\n-%>\r\n                             '<%= records[j].connection[0].srcParent %>.<%= records[j].connection[0].src %>':  <%= records[j].connection[0].srcParent %>_<%= records[j].connection[0].src %>__values,\r\n<%\r\n        }\r\n    }\r\n-%>\r\n                             '<%= records[records.length-1].connection[0].srcParent %>.<%= records[records.length-1].connection[0].src %>':  <%= records[records.length-1].connection[0].srcParent %>_<%= records[records.length-1].connection[0].src %>__values })\r\n        # step calculation\r\n<%\r\n    var stepSample = Math.pow(parseInt(doeSamples), desvars.length - 1);\r\n    for (var j = 0; j < desvars.length; j++) {\r\n        if (desvars[j].setByDriver) {\r\n-%>\r\n        <%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__values__sorted = sorted(<%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__values)\r\n        self.<%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__step = <%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__values__sorted[<%= stepSample %>] - <%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__values__sorted[0]\r\n<%\r\n        }\r\n    }\r\n-%>\r\n\r\n        # bokeh init\r\n        output_notebook()\r\n\r\n        # axes configuration\r\n<%\r\n    for (var j = 0; j < desvars.length; j++) {\r\n        if (desvars[j].setByDriver) {\r\n-%>\r\n        x_axis_values = <%= desvars[j].connection[0].dstParent %>_<%= desvars[j].connection[0].dst %>__values\r\n<%\r\n            break;\r\n        }\r\n    }\r\n-%>\r\n        y_axis_values = <%= records[0].connection[0].srcParent %>_<%= records[0].connection[0].src %>__values\r\n\r\n        # bokeh config\r\n        self.p = figure(title='<%= name %>')\r\n        self.p.add_tools(HoverTool())\r\n        self.base_scatter = self.p.circle(x_axis_values, y_axis_values, size=3, alpha=0.5)\r\n<%\r\n    var slider_desvars = [];\r\n    for (var j = 0; j < desvars.length; j++) {\r\n        if (desvars[j].setByDriver) {\r\n            slider_desvars.push({\r\n                dstParent: desvars[j].connection[0].dstParent,\r\n                dst: desvars[j].connection[0].dst,\r\n                upper: desvars[j].upper,\r\n                lower: desvars[j].lower,\r\n                value: desvars[j].value\r\n            });\r\n        }\r\n    }\r\n    // This string should include all the desvars for which sliders are to be generated\r\n    var desvar_function_signature_string = \"\";\r\n    for (var j = 0; j < slider_desvars.length; j++) {\r\n        var substring = slider_desvars[j].dst + \"_slider, \" + slider_desvars[j].dst + \"_all\";\r\n        desvar_function_signature_string += substring;\r\n        if (j < slider_desvars.length - 1)\r\n            desvar_function_signature_string += \", \";\r\n    }\r\n-%>\r\n\r\n    def update(self, x, y, <%= desvar_function_signature_string %>):\r\n        sliced_df = deepcopy(self.df)\r\n<%\r\n    // These two statements are for each slider_desvar, which check tick-box for it\r\n    for (var j = 0; j < slider_desvars.length; j++) {\r\n-%>\r\n\r\n        if not <%= slider_desvars[j].dst %>_all:\r\n            sliced_df = sliced_df.loc[isclose(sliced_df['<%= slider_desvars[j].dstParent %>.<%= slider_desvars[j].dst %>'], <%= slider_desvars[j].dst %>_slider)]\r\n<%\r\n    }\r\n-%>\r\n\r\n        self.base_scatter.data_source.data['x'] = sliced_df[x]\r\n        self.base_scatter.data_source.data['y'] = sliced_df[y]\r\n        push_notebook()\r\n\r\n    def plot (self):\r\n        self.handle = show(self.p, notebook_handle=True)\r\n<%\r\n    var domain_options_string = \"\";\r\n    var range_options_string = \"\";\r\n    for (var j = 0; j < records.length; j++) {\r\n        range_options_string += \"'\" + records[j].connection[0].srcParent + '.' + records[j].connection[0].src + \"'\";\r\n        if (j < records.length - 1) {\r\n            range_options_string += \", \";\r\n        }\r\n    }\r\n\r\n    for (var j = 0; j < slider_desvars.length; j++) {\r\n        domain_options_string += \"'\" + slider_desvars[j].dstParent + '.' + slider_desvars[j].dst + \"'\";\r\n        if (j < slider_desvars.length - 1) {\r\n            domain_options_string += \", \";\r\n        }\r\n    }\r\n-%>\r\n\r\n    def show_widgets(self):\r\n        domain_options = [<%- domain_options_string %>]\r\n        range_options = [<%- range_options_string %>]\r\n        interact(self.update,\r\n            x=widgets.Dropdown(options=domain_options, value=domain_options[0], description='Domain (X-axis)'),\r\n            y=widgets.Dropdown(options=range_options, value=range_options[0], description='Range (Y-axis)'),\r\n<%\r\n    for (var j = 0; j < slider_desvars.length; j++) {\r\n        var trailing_character;\r\n        if (j < slider_desvars.length - 1)\r\n            trailing_character = \",\";\r\n        else\r\n            trailing_character = \")\";\r\n-%>\r\n            <%= slider_desvars[j].dst %>_slider = widgets.FloatSlider(value=<%= slider_desvars[j].value %>, min=<%= slider_desvars[j].lower %>, max=<%= slider_desvars[j].upper %>, step=self.<%= slider_desvars[j].dstParent %>_<%= slider_desvars[j].dst %>__step, description='<%= slider_desvars[j].dstParent %>.<%= slider_desvars[j].dst %>'),\r\n            <%= slider_desvars[j].dst %>_all = widgets.Checkbox(description='<%= slider_desvars[j].dstParent %>.<%= slider_desvars[j].dst %> (all values)', value=True)<%= trailing_character %>\r\n<%\r\n    }\r\n}\r\n-%>\r\n",
    "moca.preprocs.generated.py.ejs": "#!/usr/bin/python\r\n\r\ndef sanity_check(param_list):\r\n    # TODO: Add the logic to check if the parameters to this methods are of equal dimensions\r\n    # TODO: Implement the method with variable arguments signature\r\n    return True\r\n\r\n<%\r\n// Create a list of inputs, pass it as a list of arguments to the definition\r\nvar inputs_list = \"\";\r\nfor (var i = 0; i < inputPorts.length; i++) {\r\n    inputs_list += inputPorts[i].name;\r\n    if (i < inputPorts.length - 1) {\r\n        inputs_list += \", \";\r\n    }\r\n}\r\n\r\n// Create a list of inputs, pass it as a list of arguments to the definition\r\nvar outputs_list = \"\";\r\nfor (var i = 0; i < outputPorts.length; i++) {\r\n    outputs_list += outputPorts[i].name;\r\n    if (i < outputPorts.length - 1) {\r\n        outputs_list += \", \";\r\n    }\r\n}\r\n-%>\r\nclass <%= name %>():\r\n    def __init__(self, <%= inputs_list %>):\r\n        # Inputs\r\n<%\r\nfor (var i = 0; i < inputPorts.length; i++) {\r\n-%>\r\n        self.<%= inputPorts[i].name %> = <%= inputPorts[i].name %>\r\n<%\r\n}\r\n-%>\r\n\r\n        # Outputs\r\n<%\r\nfor (var i = 0; i < outputPorts.length; i++) {\r\n-%>\r\n        self.<%= outputPorts[i].name %> = None\r\n<%\r\n}\r\n-%>\r\n\r\n    def apply_preprocessing(self):\r\n        # Local variables to carry the computation on\r\n<%\r\nfor (var i = 0; i < inputPorts.length; i++) {\r\n-%>\r\n        <%= inputPorts[i].name %> = self.<%= inputPorts[i].name %>\r\n<%\r\n}\r\n-%>\r\n\r\n<%\r\nfor (var i = 0; i < outputPorts.length; i++) {\r\n-%>\r\n        <%= outputPorts[i].name %> = []\r\n<%\r\n}\r\n-%>\r\n\r\n        # Sanity check for the inputs\r\n        if not sanity_check([<%= inputs_list %>]):\r\n            raise ValueError('Inputs of the preprocessor component \"<%= name %>\" are not of equal dimension')\r\n\r\n        ##### User-defined business logic of preprocessing of the data\r\n<%\r\nif (outputFunction !== '') {\r\n    // Print the user defined code snippet\r\n    var eqnLines = outputFunction.split(\"\\n\");\r\n    for (var j = 0; j < eqnLines.length; j++) {\r\n        if (eqnLines[j] !== '') {\r\n-%>\r\n        <%- eqnLines[j] %>\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n        #####\r\n\r\n        # Sanity check for the outputs\r\n        if not sanity_check([<%= outputs_list %>]):\r\n            raise ValueError('Outputs of the preprocessor component \"<%= name %>\" are not of equal dimension')\r\n\r\n<%\r\nfor (var i = 0; i < outputPorts.length; i++) {\r\n-%>\r\n        self.<%= outputPorts[i].name %> = <%= outputPorts[i].name %>\r\n<%\r\n}\r\n-%>\r\n\r\n        return\r\n",
    "moca.problem.generated.ipynb.ejs": "{\r\n \"cells\": [\r\n  {\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"# <%= name %> Notebook\\n\",\r\n      \"***\",\r\n      \"\\n\",\r\n      \"## Instantiation and execution\\n\",\r\n      \"\\n\",\r\n      \"Import the problem.\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"from src.<%= name %> import <%= name %>\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Instantiate the problem.\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"top = <%= name %>()\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Run the problem.\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Assign values to design variable(s).\"\r\n      ,\"\\n\"\r\n<%\r\nfor (var i = 0; i < desvars.length; i++) {\r\n    var valueString = desvars[i].value.toString();\r\n    if (valueString.indexOf('.') === -1) {\r\n        valueString += '.0';\r\n    }\r\n-%>\r\n      ,\"top['<%= desvars[i].name %>.<%= desvars[i].connection[0].dst %>'] = <%= valueString %>\"\r\n      ,\"\\n\"\r\n<%\r\n}\r\n-%>\r\n      ,\"# Execute the problem.\"\r\n      ,\"\\n\"\r\n      ,\"top.run()\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"***\",\r\n      \"\\n\",\r\n      \"## Analysis\\n\"\r\n<%\r\nif (driver === 'ScipyOptimizer') {\r\n-%>\r\n      ,\"\\n\"\r\n      ,\"_**Optimization analysis**_\\n\"\r\n      ,\"\\n\"\r\n      ,\"**Objectives**\"\r\n<%\r\n}\r\n-%>\r\n   ]\r\n  }\r\n<%\r\nif (driver === 'ScipyOptimizer' || driver === 'Default (run once)') {\r\n    if (driver === 'ScipyOptimizer') {\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Print objectives' values\"\r\n      ,\"\\n\"\r\n<%\r\n        for (var i = 0; i < objectives.length; i++) {\r\n-%>\r\n      ,\"print(\\\"<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %> = %f \\\" % (top['<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>']))\"\r\n<%\r\n            if (i != objectives.length - 1) {\r\n-%>\r\n      ,\"\\n\"\r\n<%\r\n            }\r\n        }\r\n-%>\r\n   ]\r\n  }\r\n<%\r\n    }\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"**Design Variables**\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Print design variables' values\"\r\n      ,\"\\n\"\r\n<%\r\n    for (var i = 0; i < desvars.length; i++) {\r\n-%>\r\n      ,\"print(\\\"<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %> = %f\\\" % (top['<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>']))\"\r\n<%\r\n        if (i != desvars.length - 1) {\r\n-%>\r\n      ,\"\\n\"\r\n<%\r\n        }\r\n    }\r\n-%>\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"**Recorded/Monitored variables**\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n      \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Print recorded/monitored variables' values\"\r\n      ,\"\\n\"\r\n<%\r\n    for (var i = 0; i < records.length; i++) {\r\n-%>\r\n      ,\"print(\\\"<%= records[i].connection[0].srcParent %>.<%= records[i].connection[0].src %> = %f\\\" % (top['<%= records[i].connection[0].srcParent %>.<%= records[i].connection[0].src %>']))\"\r\n<%\r\n        if (i != records.length - 1) {\r\n-%>\r\n      ,\"\\n\"\r\n<%\r\n        }\r\n    }\r\n-%>\r\n   ]\r\n  }\r\n<%\r\n} else if (driver === 'FullFactorialDOE') {\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"_**Design-of-experiment analysis**_\\n\"\r\n      ,\"\\n\"\r\n      ,\"*Recording*\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Use utilities to parse and plot the output.\"\r\n    ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"from utils.MOCAparseutils import SqliteParseUtils\\n\"\r\n      ,\"from utils.moca_plotutils.<%= name %>_plotutils import <%= name %>_PlotUtils\\n\"\r\n      ,\"plotutils = <%= name %>_PlotUtils(SqliteParseUtils(top))\\n\"\r\n      ,\"plotutils.plot()\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Use widgets to interact with the plot.\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n      \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"plotutils.show_widgets()\"\r\n   ]\r\n  }\r\n<%\r\n}\r\n-%>\r\n  ,{\r\n    \"cell_type\": \"markdown\",\r\n    \"metadata\": {},\r\n    \"source\": [\r\n      \"***\",\r\n      \"\\n\",\r\n      \"## Results\\n\",\r\n      \"The results of the analysis can be downloaded by using the following links -\"\r\n    ]\r\n  }\r\n  ,{\r\n    \"cell_type\": \"code\",\r\n    \"execution_count\": null,\r\n    \"metadata\": {\r\n        \"collapsed\": true\r\n    },\r\n    \"outputs\": [],\r\n    \"source\": [\r\n        \"from utils.MOCAparseutils import ResultsAccessUtils\",\r\n        \"\\n\",\r\n        \"ResultsAccessUtils().get_result_files('<%= name %>')\"\r\n    ]\r\n  }\r\n ],\r\n  \"metadata\": {\r\n  \"kernelspec\": {\r\n   \"display_name\": \"Python 2\",\r\n   \"language\": \"python\",\r\n   \"name\": \"python2\"\r\n  },\r\n  \"language_info\": {\r\n   \"codemirror_mode\": {\r\n    \"name\": \"ipython\",\r\n    \"version\": 2\r\n   },\r\n   \"file_extension\": \".py\",\r\n   \"mimetype\": \"text/x-python\",\r\n   \"name\": \"python\",\r\n   \"nbconvert_exporter\": \"python\",\r\n   \"pygments_lexer\": \"ipython2\",\r\n   \"version\": \"2.7.9\"\r\n  }\r\n },\r\n \"nbformat\": 4,\r\n \"nbformat_minor\": 0\r\n}\r\n",
    "moca.problemcomps.generated.py.ejs": "#!/usr/bin/python\r\nfrom openmdao.api import Component\r\nfrom <%= name %> import <%= name %>\r\n\r\n<%\r\n// Generate the code the component\r\n-%>\r\nclass <%= name %>__MOCAComponent(Component):\r\n    def __init__(self):\r\n        super(<%= name %>__MOCAComponent, self).__init__()\r\n<%\r\n// Generate \"add_output\" statements\r\nfor (var j = 0; j < promotes.length; j++) {\r\n    if (promotes[j].srcMeta === 'InPromote') {\r\n-%>\r\n        self.add_param('<%= promotes[j].src %>', val=0.0)\r\n<%\r\n    }\r\n}\r\n-%>\r\n<%\r\n// Generate \"add_output\" and \"add_state\" statements\r\nfor (j = 0; j < promotes.length; j++) {\r\n    if (promotes[j].srcMeta === 'OutPromote') {\r\n-%>\r\n        self.add_output('<%= promotes[j].src %>', val=0.0)\r\n<%\r\n    }\r\n}\r\n-%>\r\n\r\n        self.deriv_options['type'] = 'fd'\r\n\r\n    def solve_nonlinear(self, params, unknowns, resids):\r\n        # Instantiate the problem\r\n        problem = <%= name %>()\r\n\r\n        # Feed the parameters\r\n<%\r\nfor (j = 0; j < promotes.length; j++) {\r\n    if (promotes[j].srcMeta === 'InPromote') {\r\n-%>\r\n        problem['<%= promotes[j].dstParent %>.<%= promotes.dst %>'] = params['<%= promotes[j].src %>']\r\n<%\r\n    }\r\n}\r\n-%>\r\n\r\n        # Execute the problem\r\n        problem.setup()\r\n        problem.run()\r\n\r\n        # Assign the value(s) to unknown(s)\r\n<%\r\nfor (j = 0; j < promotes.length; j++) {\r\n    if (promotes[j].srcMeta === 'OutPromote') {\r\n-%>\r\n        unknowns['<%= promotes[j].src %>'] = problem['<%= promotes[j].dstParent %>.<%= promotes[j].dst %>']\r\n<%\r\n    }\r\n}\r\n-%>\r\n",
    "moca.problems.generated.py.ejs": "#!/usr/bin/python\r\n\r\n# Static imports\r\nfrom openmdao.api import IndepVarComp, Group, Problem\r\n<%\r\nvar driverDictionary = {\r\n    'ScipyOptimizer': 'ScipyOptimizer',\r\n    'FullFactorialDOE': 'FullFactorialDriver'\r\n}\r\n// Generate the code for import statement for components\r\nfor (var i = 0; i < compInstances.length; i++) {\r\n-%>\r\nfrom lib.moca_components.<%= compInstances[i].base %> import <%= compInstances[i].base %>\r\n<%\r\n}\r\n// Generate the code for import statement for data driven components\r\nfor (i = 0; i < ddCompInstances.length; i++) {\r\n-%>\r\nfrom lib.moca_ddmodels.<%= ddCompInstances[i].base %>.<%= ddCompInstances[i].base %>__MOCAComponent import <%= ddCompInstances[i].base %>\r\n<%\r\n}\r\nfor (i = 0 ; i < processFlowInstances.length; i++) {\r\n-%>\r\nfrom lib.moca_desmodels.<%= processFlowInstances[i].base %>.<%= processFlowInstances[i].base %>__MOCAComponent import <%= processFlowInstances[i].base %>\r\n<%\r\n}\r\nfor (i = 0; i < groupInstances.length; i++) {\r\n-%>\r\nfrom lib.moca_groups.<%= groupInstances[i].base %> import <%= groupInstances[i].base %>\r\n<%\r\n}\r\nfor (i = 0; i < problemInstances.length; i++) {\r\n-%>\r\nfrom <%= problemInstances[i].base%>__MOCAComponent import <%= problemInstances[i].base %>__MOCAComponent\r\n<%\r\n}\r\n-%>\r\n\r\n# Dynamic imports\r\n<%\r\nif (driver !== 'Default (run once)') {\r\n-%>\r\nfrom openmdao.api import <%= driverDictionary[driver] %>\r\n<%\r\n}\r\n-%>\r\nfrom openmdao.api import DumpRecorder, SqliteRecorder\r\nfrom openmdao.recorders.csv_recorder import CsvRecorder\r\n<%\r\nif (algebraicLoop) {\r\n-%>\r\nfrom openmdao.api import NLGaussSeidel, ScipyGMRES\r\n<%\r\n}\r\n-%>\r\n\r\nclass RootGroup(Group):\r\n    def __init__(self):\r\n        super(RootGroup, self).__init__()\r\n\r\n        # Add design variables (independently varying components)\r\n<%\r\n// add() statements for design variables\r\nfor (i = 0; i < desvars.length; i++) {\r\n    var valueString = desvars[i].value.toString();\r\n    if (valueString.indexOf('.') === -1) {\r\n        valueString += '.0';\r\n    }\r\n-%>\r\n        self.add('<%= desvars[i].name %>', IndepVarComp('<%= desvars[i].connection[0].dst %>', <%= valueString %>))\r\n<%\r\n}\r\n-%>\r\n\r\n        # Add component instances\r\n<%\r\n// Generate the code for add() statements for components -\r\n// add instances of components\r\nfor (i = 0; i < compInstances.length; i++) {\r\n    promotesString = '';\r\n    for (var j = 0; j < compInstances[i].promotes.length; j++) {\r\n        promotesString += \"'\" + compInstances[i].promotes[j] + \"'\";\r\n        if (j != compInstances[i].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= compInstances[i].name %>', <%= compInstances[i].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n}\r\n-%>\r\n\r\n        # Add data-driven component instances\r\n<%\r\n// Generate the code for add() statements for data-driven components -\r\n// add instances of components\r\nfor (i = 0; i < ddCompInstances.length; i++) {\r\n    promotesString = '';\r\n    for (j = 0; j < ddCompInstances[i].promotes.length; j++) {\r\n        promotesString += \"'\" + ddCompInstances[i].promotes[j] + \"'\";\r\n        if (j != ddCompInstances[i].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= ddCompInstances[i].name %>', <%= ddCompInstances[i].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n}\r\n-%>\r\n\r\n        # Add problem component instances\r\n<%\r\n// Generate the code for add() statements for problem components -\r\nfor (i = 0; i < problemInstances.length; i++) {\r\n    promotesString = '';\r\n    for (j = 0; j < problemInstances[i].promotes.length; j++) {\r\n        promotesString += \"'\" + problemInstances[i].promotes[j] + \"'\";\r\n        if (j != problemInstances[i].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= problemInstances[i].name %>', <%= problemInstances[i].base %>__MOCAComponent(), promotes=[])\r\n<%\r\n}\r\n-%>\r\n\r\n        # Add SimPy simulation component instance\r\n<%\r\nfor (i = 0; i < processFlowInstances.length; i++) {\r\n    promotesString = '';\r\n    for (j = 0; j < processFlowInstances[i].promotes.length; j++) {\r\n        promotesString += \"'\" + processFlowInstances[i].promotes[j] + \"'\";\r\n        if (j != processFlowInstances[i].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= processFlowInstances[i].name %>', <%= processFlowInstances[i].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n}\r\n-%>\r\n\r\n        # Add group instances\r\n<%\r\n// Generate the code for add() statements for groups -\r\n// add instances of groups\r\nfor (i = 0; i < groupInstances.length; i++) {\r\n    var promotesString = '';\r\n    for (j = 0; j < groupInstances[i].promotes.length; j++) {\r\n        promotesString += \"'\" + groupInstances[i].promotes[j] + \"'\";\r\n        if (j != groupInstances[i].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= groupInstances[i].name %>', <%= groupInstances[i].base %>(), promotes=[])\r\n<%\r\n}\r\n-%>\r\n\r\n        # Add connections between the ports\r\n<%\r\n// Generate the code for connect() statements for connections between ports\r\nfor (i = 0; i < connections.length; i++) {\r\n-%>\r\n        self.connect('<%= connections[i].srcParent %>.<%= connections[i].src %>', '<%= connections[i].dstParent %>.<%= connections[i].dst %>')\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Generate the code for connect() statements for connections\r\n// between IndepVarComps' ports and ports\r\nfor (i = 0; i < desvars.length; i++) {\r\n-%>\r\n        self.connect('<%= desvars[i].name %>.<%= desvars[i].connection[0].dst %>', '<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>')\r\n<%\r\n}\r\n-%>\r\n\r\n        # Special solvers for handling algebraic loops\r\n<%\r\n// Change nl_solver and ln_driver in case of algebraic loop\r\nif (algebraicLoop) {\r\n-%>\r\n        self.nl_solver = NLGaussSeidel()\r\n        self.nl_solver.options['atol'] = 1.0e-12\r\n        self.ln_solver = ScipyGMRES()\r\n<%\r\n}\r\n-%>\r\n\r\n\r\nclass <%= name %>(Problem):\r\n    def __init__(self):\r\n        super(<%= name %>, self).__init__()\r\n\r\n        self.root = RootGroup()\r\n\r\n        # Add driver\r\n<%\r\n// Driver settings\r\nif (driver === 'ScipyOptimizer') {\r\n-%>\r\n        self.driver = ScipyOptimizer()\r\n        self.driver.options['optimizer'] = 'SLSQP'\r\n\r\n<%\r\n    for (i = 0; i < constraints.length; i++) {\r\n        var limitsString = '';\r\n        if (constraints[i].enableUpper) {\r\n            limitsString = 'upper=';\r\n            valueString = constraints[i].upper;\r\n            if (valueString.indexOf('.') === -1)\r\n                valueString += '.0';\r\n            limitsString += valueString;\r\n        }\r\n        if (constraints[i].enableLower) {\r\n            limitsString += ', lower=';\r\n            valueString = constraints[i].lower;\r\n            if (valueString.indexOf('.') === -1)\r\n                valueString += '.0';\r\n            limitsString += valueString;\r\n        }\r\n        if (!constraints[i].enableLower && !constraints[i].enableUpper)\r\n            break;\r\n-%>\r\n        self.driver.add_constraint('<%= constraints[i].connection[0].srcParent %>.<%= constraints[i].connection[0].src %>', <%= limitsString %>)\r\n<%\r\n    }\r\n-%>\r\n<%\r\n} else if (driver === 'FullFactorialDOE') {\r\n-%>\r\n        self.driver = FullFactorialDriver(<%= doeSamples %>)\r\n<%\r\n}\r\n-%>\r\n\r\n        # Add recorders to the driver\r\n        rec = DumpRecorder('out/text/<%= name %>/<%= name %>.txt')\r\n        rec.options['record_params'] = True\r\n        rec.options['record_metadata'] = True\r\n        self.driver.add_recorder(rec)\r\n        f = open('out/text/<%= name %>/<%= name %>.csv', 'w')\r\n        rec = CsvRecorder(f)\r\n        rec.options['record_params'] = True\r\n        self.driver.add_recorder(rec)\r\n<%\r\nif (driver === 'FullFactorialDOE') {\r\n-%>\r\n        rec = SqliteRecorder('out/bin/<%= name %>/<%= name %>.sqlite3')\r\n        rec.options['record_params'] = True\r\n        rec.options['record_metadata'] = True\r\n        self.driver.add_recorder(rec)\r\n<%\r\n}\r\n-%>\r\n        # Let the driver know about design variables\r\n<%\r\n// add_desvar() statements for design variables\r\nfor (i = 0; i < desvars.length; i++) {\r\n    if (desvars[i].setByDriver) {\r\n        var upperString = desvars[i].upper.toString(),\r\n            lowerString = desvars[i].lower.toString();\r\n        if (upperString.indexOf('.') === -1) {\r\n            upperString += '.0';\r\n        }\r\n        if (lowerString.indexOf('.') === -1) {\r\n            lowerString += '.0';\r\n        }\r\n-%>\r\n        self.driver.add_desvar('<%= desvars[i].name %>.<%= desvars[i].connection[0].dst %>', lower=<%= lowerString %>, upper=<%= upperString %>)\r\n<%\r\n    }\r\n}\r\n-%>\r\n\r\n        # Add objective (in case of optimization)\r\n        # Adding multiple objectives can cause erroneous behavior\r\n<%\r\nif (driver === 'ScipyOptimizer') {\r\n    // add_objective() statements for objectives -- although only 1 objective is supported\r\n    for (i = 0; i < objectives.length; i++) {\r\n-%>\r\n        self.driver.add_objective('<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>')\r\n<%\r\n    }\r\n}\r\n-%>\r\n        self.setup()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    top = <%= name %>()\r\n\r\n    print \"Running the MOCA problem <%= name %>\"\r\n\r\n    top.run()\r\n\r\n    print \"Result:\"\r\n    print \"------\"\r\n\r\n<%\r\n// Print result in case of optimizer\r\nif (driver === 'ScipyOptimizer') {\r\n-%>\r\n    print \"\\tObjective(s):\"\r\n    print \"\\t------------\"\r\n<%\r\n    for (i = 0; i < objectives.length; i++) {\r\n-%>\r\n    print(\"\\t\\t<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %> = %f\" % (top['<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>']))\r\n<%\r\n    }\r\n-%>\r\n    print \"\\tDesign variable(s):\"\r\n    print \"\\t------------------\"\r\n<%\r\n    for (i = 0; i < desvars.length; i++) {\r\n-%>\r\n    print(\"\\t\\t<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %> = %f\" % (top['<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>']))\r\n<%\r\n    }\r\n} else {\r\n-%>\r\n    print \"The DOE result is written in a file named <%= name %>_dumpfile or <%= name %>_sqlitefile in the parent folder.\"\r\n<%\r\n}\r\n-%>\r\n",
    "moca.processflow.generated.ipynb.ejs": "{\r\n    \"cells\": [\r\n        {\r\n            \"cell_type\": \"markdown\",\r\n            \"metadata\": {},\r\n            \"source\": [\r\n                \"# <%= name %> SimPy Notebook\\n\",\r\n                \"***\",\r\n                \"\\n\",\r\n                \"## Execution\\n\",\r\n                \"\\n\",\r\n                \"Import the DES model code.\"\r\n            ]\r\n        }\r\n        ,{\r\n            \"cell_type\": \"code\",\r\n            \"execution_count\": null,\r\n            \"metadata\": {\r\n                \"collapsed\": true\r\n            },\r\n            \"outputs\": [],\r\n            \"source\": [\r\n                \"from <%= name %> import <%= name %>__SimPy_simulation\",\r\n                \"\\n\",\r\n                \"pf_model = <%= name %>__SimPy_simulation()\",\r\n                \"\\n\",\r\n                \"pf_model.simulate()\"\r\n            ]\r\n        }\r\n        ,{\r\n            \"cell_type\": \"markdown\",\r\n            \"metadata\": {},\r\n            \"source\": [\r\n                \"## Visualization\\n\"\r\n            ]\r\n        }\r\n<%\r\nfor (var i=0; i < buffers.length; i++) {\r\n    var buffer = buffers[i];\r\n-%>\r\n        ,{\r\n            \"cell_type\": \"markdown\",\r\n            \"metadata\": {},\r\n            \"source\": [\r\n                \"Buffer usage of <%= buffer.name %>\"\r\n            ]\r\n        }\r\n        ,{\r\n            \"cell_type\": \"code\",\r\n            \"execution_count\": null,\r\n            \"metadata\": {\r\n            \"collapsed\": true\r\n            },\r\n            \"outputs\": [],\r\n            \"source\": [\r\n                \"%matplotlib inline\",\r\n                \"\\n\",\r\n                \"import matplotlib.pyplot as plt\",\r\n                \"\\n\",\r\n                \"plt.plot(pf_model.simulation_states['timestamps'], pf_model.simulation_states['buff_<%= buffer.name %>_usage'])\",\r\n                \"\\n\",\r\n                \"plt.title('Buffer usage of <%= buffer.name %>')\",\r\n                \"\\n\",\r\n                \"plt.show()\"\r\n            ]\r\n        }\r\n<%\r\n}\r\n-%>\r\n    ],\r\n    \"metadata\": {\r\n        \"kernelspec\": {\r\n            \"display_name\": \"Python 2\",\r\n            \"language\": \"python\",\r\n            \"name\": \"python2\"\r\n        },\r\n        \"language_info\": {\r\n            \"codemirror_mode\": {\r\n                \"name\": \"ipython\",\r\n                \"version\": 2\r\n            },\r\n            \"file_extension\": \".py\",\r\n            \"mimetype\": \"text/x-python\",\r\n            \"name\": \"python\",\r\n            \"nbconvert_exporter\": \"python\",\r\n            \"pygments_lexer\": \"ipython2\",\r\n            \"version\": \"2.7.9\"\r\n        }\r\n    },\r\n    \"nbformat\": 4,\r\n    \"nbformat_minor\": 0\r\n}\r\n",
    "moca.processflows.generated.py.ejs": "import simpy\r\n\r\nclass <%= name %>__SimPy_simulation():\r\n    def __init__(self, params=None):\r\n        if params is not None:\r\n<%\r\nfor (var i = 0; i < desInterfaces.length; i++) {\r\n    var desInterface = desInterfaces[i];\r\n    // If the desInterface is a Parameter\r\n    if (desInterface.srcMeta === 'in') {\r\n        // if the param / result is a child of the process/buffer itself\r\n        if (desInterface.dstGrandParent === null) {\r\n-%>\r\n            self.<%= desInterface.dstParent %>__<%= desInterface.dstMeta %> = params['<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>']\r\n<%\r\n        } else {\r\n-%>\r\n            self.<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %> = params['<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>']\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n            pass\r\n        else:\r\n<%\r\nfor (var i = 0; i < desInterfaces.length; i++) {\r\n    var desInterface = desInterfaces[i];\r\n    // If the desInterface is a Parameter\r\n    if (desInterface.srcMeta === 'in') {\r\n    // if the param / result is a child of the process/buffer itself\r\n        if (desInterface.dstGrandParent === null) {\r\n-%>\r\n            self.<%= desInterface.dstParent %>__<%= desInterface.dstMeta %> = <%= desInterface.dstValue %>\r\n<%\r\n        } else {\r\n-%>\r\n            self.<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %> = <%= desInterface.dstValue %>\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n            pass\r\n\r\n        # SimPy environment\r\n        self.env = simpy.Environment()\r\n\r\n        # Simulation states\r\n        self.simulation_states = {\r\n            'timestamps': [],\r\n<%\r\nfor (i = 0; i < buffers.length; i++) {\r\n-%>\r\n            'buff_<%= buffers[i].name %>_usage': [],\r\n<%\r\n}\r\n-%>\r\n        }\r\n\r\n        # Simulation results\r\n        self.simulation_results = {}\r\n<%\r\nfor (i = 0; i < processes.length; i++) {\r\n-%>\r\n        self.simulation_results['<%= processes[i].name %>__TotalPartsProduced'] = 0\r\n        self.simulation_results['<%= processes[i].name %>__TotalWaitingTime'] = 0\r\n<%\r\n}\r\n-%>\r\n\r\n\r\n        # SimPy process for monitoring simulation\r\n        self.sim_monitor = self.env.process(self.monitor(self.env))\r\n\r\n        # SimPy processes for shifts\r\n<%\r\nfor (i = 0; i < processes.length; i++) {\r\n-%>\r\n        self.<%= processes[i].name %> = self.env.process(self.<%= processes[i].name %>__shift_controller(self.env))\r\n<%\r\n}\r\n-%>\r\n\r\n        # SimPy stores for buffers\r\n<%\r\nfor (i = 0; i< buffers.length; i++) {\r\n    if (buffers[i].size.desParam === false) {\r\n-%>\r\n        self.<%= buffers[i].name %> = simpy.Store(self.env, capacity=<%= buffers[i].size.value %>)\r\n<%\r\n    } else {\r\n        var desInterfaceIndex = -1;\r\n        for (var j = 0; j < desInterfaces.length; j++) {\r\n            if ((desInterfaces[j].dstMeta === 'Size') && (desInterfaces[j].dstParent === buffers[i].name)) {\r\n                desInterfaceIndex = j;\r\n                break;\r\n            }\r\n        }\r\n        if (desInterfaceIndex != -1) {\r\n-%>\r\n        self.<%= buffers[i].name %> = simpy.Store(self.env, capacity=self.<%= desInterfaces[desInterfaceIndex].dstParent %>__<%= desInterfaces[desInterfaceIndex].dstMeta %>)\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n\r\n    # Methods for SimPy processes (for shifts and internal business logic)\r\n<%\r\nfor (i = 0; i < processes.length; i++) {\r\n-%>\r\n    def <%= processes[i].name %>__shift_controller(self, simpy_env):\r\n        while True:\r\n            # Start production\r\n            <%= processes[i].name %>_proc = simpy_env.process(self.<%= processes[i].name %>__business_logic(simpy_env))\r\n<%\r\n    if (processes[i].processShiftOnTime.desParam === false) {\r\n-%>\r\n            yield simpy_env.timeout(<%= processes[i].processShiftOnTime.value %>)\r\n<%\r\n    } else {\r\n        desInterfaceIndex = -1;\r\n        for (j = 0; j < desInterfaces.length; j++) {\r\n            if ((desInterfaces[j].dstMeta === 'ProcessONTime') && (desInterfaces[j].dstParent === processes[i].name)) {\r\n                desInterfaceIndex = j;\r\n                break;\r\n            }\r\n        }\r\n        if (desInterfaceIndex != -1) {\r\n-%>\r\n            yield simpy_env.timeout(self.<%= desInterfaces[desInterfaceIndex].dstParent %>__<%= desInterfaces[desInterfaceIndex].dstMeta %>)\r\n<%\r\n        }\r\n    }\r\n-%>\r\n\r\n            # Stop production\r\n            <%= processes[i].name %>_proc.interrupt(\"end_of_shift\")\r\n<%\r\n    if (processes[i].processShiftOnTime.desParam === false) {\r\n-%>\r\n            yield simpy_env.timeout(<%= processes[i].processShiftOffTime.value %>)\r\n<%\r\n    } else {\r\n        desInterfaceIndex = -1;\r\n        for (j = 0; j < desInterfaces.length; j++) {\r\n            if ((desInterfaces[j].dstMeta === 'ProcessOFFTime') && (desInterfaces[j].dstParent === processes[i].name)) {\r\n                desInterfaceIndex = j;\r\n                break;\r\n            }\r\n        }\r\n        if (desInterfaceIndex != -1) {\r\n-%>\r\n            yield simpy_env.timeout(self.<%= desInterfaces[desInterfaceIndex].dstParent %>__<%= desInterfaces[desInterfaceIndex].dstMeta %>)\r\n<%\r\n        }\r\n    }\r\n-%>\r\n\r\n    def <%= processes[i].name %>__business_logic(self, simpy_env):\r\n        # A unique item ID needs to be associated with every item to push it into buffers (restriction by SimPy)\r\n        item_id = 0\r\n        while True:\r\n            try:\r\n                # Get the input material (or in case of processes at the start of the chain, don't do anything)\r\n<%\r\n    // Filter every such connection for which this process is dst\r\n    // TODO: Not all processes will need from every upstream buffer, some will need from only 1 of them to function\r\n    // (AND/OR functions of the incoming buffer)\r\n    for (j = 0; j < connections.length; j++) {\r\n        if (connections[j].name == 'BuffToProcFlow' && connections[j].dst == processes[i].name) {\r\n-%>\r\n                yield self.<%= connections[j].src %>.get()\r\n<%\r\n        }\r\n    }\r\n-%>\r\n\r\n                # Simulate production\r\n<%\r\n    if (processes[i].processingTime.desParam === false) {\r\n%>\r\n                yield simpy_env.timeout(<%= processes[i].processingTime.value %>)\r\n<%\r\n    } else {\r\n        desInterfaceIndex = -1;\r\n        for (j = 0; j < desInterfaces.length; j++) {\r\n            if ((desInterfaces[j].dstMeta === 'ProcessingTime') && (desInterfaces[j].dstParent === processes[i].name)) {\r\n                desInterfaceIndex = j;\r\n                break;\r\n            }\r\n        }\r\n        if (desInterfaceIndex != -1) {\r\n-%>\r\n                yield simpy_env.timeout(self.<%= desInterfaces[desInterfaceIndex].dstParent %>__<%= desInterfaces[desInterfaceIndex].dstMeta %>)\r\n<%\r\n        }\r\n    }\r\n-%>\r\n                # Increment the number of parts produced\r\n                self.simulation_results['<%= processes[i].name %>__TotalPartsProduced'] += 1\r\n\r\n                # Put the processed material into the buffer (assumption: process is storing the part in only one buffer)\r\n<%\r\n    // Filter the first connection for which this process is src\r\n    for (j = 0; j < connections.length; j++) {\r\n        if (connections[j].name == 'ProcToBuffFlow' && connections[j].src == processes[i].name) {\r\n-%>\r\n                yield self.<%= connections[j].dst %>.put(\"<%= processes[i].name %>_%s\" % item_id)\r\n                item_id += 1\r\n<%\r\n            break;\r\n        }\r\n    }\r\n-%>\r\n            except simpy.Interrupt as i:\r\n                return\r\n\r\n<%\r\n}\r\n-%>\r\n\r\n    # Method to monitor simulation stats\r\n    def monitor(self, simpy_env):\r\n        while True:\r\n            yield simpy_env.timeout(0.1)\r\n            self.simulation_states['timestamps'].append(simpy_env.now)\r\n<%\r\nfor (i = 0; i < buffers.length; i++) {\r\n-%>\r\n            self.simulation_states['buff_<%= buffers[i].name %>_usage'].append(len(self.<%= buffers[i].name %>.items))\r\n<%\r\n}\r\n-%>\r\n\r\n    # Method to simulate the SimPy simulation\r\n    def simulate(self):\r\n        results = {}\r\n        self.env.run(until=<%= simend %>)\r\n<%\r\nfor (i = 0; i < desInterfaces.length; i++) {\r\n    desInterface = desInterfaces[i];\r\n    // If the desInterface is a Parameter\r\n    if (desInterface.srcMeta === 'out') {\r\n    // if the param / result is a child of the process/buffer itself\r\n        if (desInterface.dstGrandParent === null) {\r\n-%>\r\n        results['<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>'] = self.simulation_results['<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>']\r\n<%\r\n        } else {\r\n-%>\r\n        results['<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>'] = self.simulation_results['<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>']\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n        return results\r\n",
    "moca.procflowcomps.generated.py.ejs": "#!/usr/bin/python\r\nfrom openmdao.api import Component\r\nfrom <%= name %> import <%= name %>__SimPy_simulation\r\n\r\n<%\r\n// Generate the code the component\r\n-%>\r\nclass <%= name %>(Component):\r\n    def __init__(self):\r\n        super(<%= name %>, self).__init__()\r\n<%\r\n// Generate \"add_param\" statements\r\nfor (var i = 0; i < desInterfaces.length; i++) {\r\n    if (desInterfaces[i].srcMeta === 'in') {\r\n        var valueString = desInterfaces[i].srcValue.toString();\r\n        if (valueString.indexOf('.') === -1)\r\n            valueString += '.0';\r\n-%>\r\n        self.add_param('<%= desInterfaces[i].src %>', val=<%= valueString %>)\r\n<%\r\n    }\r\n}\r\n// Generate \"add_output\" and \"add_state\" statements\r\nfor (i = 0; i < desInterfaces.length; i++) {\r\n    if (desInterfaces[i].srcMeta === 'out') {\r\n        valueString = desInterfaces[i].srcValue.toString();\r\n        if (valueString.indexOf('.') === -1)\r\n            valueString += '.0';\r\n-%>\r\n        self.add_output('<%= desInterfaces[i].src %>', val=<%= valueString %>)\r\n<%\r\n    }\r\n}\r\n-%>\r\n\r\n        self.deriv_options['type'] = 'fd'\r\n\r\n    def solve_nonlinear(self, params, unknowns, resids):\r\n        ## Feed the **vector** of parameters to the DES model\r\n        parameters = {}\r\n<%\r\nfor (i = 0; i < desInterfaces.length; i++) {\r\n    var desInterface = desInterfaces[i];\r\n    // If the desInterface is a Parameter\r\n    if (desInterface.srcMeta === 'in') {\r\n        // if the param / result is a child of the process/buffer itself\r\n        if (desInterface.dstGrandParent === null) {\r\n-%>\r\n        parameters['<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>'] = params['<%= desInterface.src %>']\r\n<%\r\n        } else {\r\n-%>\r\n        parameters['<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>'] = params['<%= desInterface.src %>']\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n        des_model = <%= name %>__SimPy_simulation(params=parameters)\r\n        results = des_model.simulate()\r\n\r\n        # Assign the value(s) to unknown(s)\r\n<%\r\nfor (i = 0; i < desInterfaces.length; i++) {\r\n    desInterface = desInterfaces[i];\r\n    // If the desInterface is a Unknown\r\n    if (desInterface.srcMeta === 'out') {\r\n        // if the param / result is a child of the process/buffer itself\r\n        if (desInterface.dstGrandParent === null) {\r\n-%>\r\n        unknowns['<%= desInterface.src %>'] = results['<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>']\r\n<%\r\n        } else {\r\n-%>\r\n        unknowns['<%= desInterface.src %>'] = results['<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>']\r\n<%\r\n        }\r\n    }\r\n}\r\n-%>\r\n"
}});