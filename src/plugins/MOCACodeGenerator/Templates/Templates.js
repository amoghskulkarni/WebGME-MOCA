/* Generated file based on ejs templates */
define([], function() {
    return {
    "moca.components.generated.py.ejs": "#!/usr/bin/python\r\nfrom openmdao.api import Component\r\nimport sys\r\n\r\n<%\r\n// Generate the code for all the components\r\nfor (var i = 0; i < comps.length; i++) {\r\n-%>\r\nclass <%= comps[i].name %>(Component):\r\n    def __init__(self):\r\n        super(<%= comps[i].name %>, self).__init__()\r\n<%\r\n    // Generate \"add_param\" statements\r\n    for (var j = 0; j < comps[i].parameters.length; j++) {\r\n        valueString = comps[i].parameters[j].value;\r\n        if (valueString.indexOf('.') === -1)\r\n            valueString += '.0';\r\n-%>\r\n        self.add_param('<%= comps[i].parameters[j].name %>', val=<%= comps[i].parameters[j].value %>)\r\n<%\r\n    }\r\n-%>\r\n<%\r\n    // Generate \"add_output\" and \"add_state\" statements\r\n    for (var j = 0; j < comps[i].unknowns.length; j++) {\r\n        var unknown_type;\r\n        if (comps[i].unknowns[j].type == 'Output') {\r\n            unknown_type = 'output';\r\n        } else {\r\n            unknown_type = 'state';\r\n        }\r\n        valueString = comps[i].unknowns[j].value;\r\n        if (valueString.indexOf('.') === -1)\r\n            valueString += '.0';\r\n-%>\r\n        self.add_<%= unknown_type %>('<%= comps[i].unknowns[j].name %>', val=<%= comps[i].unknowns[j].value %>)\r\n<%\r\n    }\r\n-%>\r\n<%\r\n    // Generate statement configuring force_fd\r\n    if (comps[i].force_fd === true) {\r\n-%>\r\n        self.fd_options['force_fd'] = True\r\n<%\r\n    }\r\n-%>\r\n\r\n    def solve_nonlinear(self, params, unknowns, resids):\r\n        # Assigning shorthand(s) to the parameter(s)\r\n<%\r\n    // Generate statements for dummy implementation of the method\r\n    for (var j = 0; j < comps[i].parameters.length; j++) {\r\n-%>\r\n        <%= comps[i].parameters[j].name %> = params['<%= comps[i].parameters[j].name %>']\r\n<%\r\n    }\r\n-%>\r\n\r\n<%\r\n    // Generate statements to give explicit equation between output(s) and input(s)\r\n    if (comps[i].outputFunction === '') {\r\n        // Print the dummy code snippet if the user hasn't given one\r\n        var dummyStatement = '';\r\n        for (var j = 0; j < comps[i].parameters.length; j++) {\r\n            dummyStatement += comps[i].parameters[j].name;\r\n            if (j != comps[i].parameters.length - 1)\r\n                dummyStatement += ' + ';\r\n        }\r\n        for (var j = 0; j < comps[i].unknowns.length; j++) {\r\n-%>\r\n        # Dummy function for the unknown <%= comps[i].unknowns[j].name %>\r\n        <%= comps[i].unknowns[j].name %> = <%= dummyStatement %>\r\n<%\r\n        }\r\n    } else {\r\n-%>\r\n        # This code snippet is defined by user using the embedded code editor in MOCA\r\n<%\r\n        // Print the user defined code snippet\r\n        var eqnLines = comps[i].outputFunction.split(\"\\n\");\r\n        for (var j = 0; j < eqnLines.length; j++) {\r\n            if (eqnLines[j] !== '') {\r\n-%>\r\n        <%- eqnLines[j] %>\r\n<%\r\n            }\r\n        }\r\n    }\r\n-%>\r\n\r\n        # Assign the value(s) to unknown(s)\r\n<%\r\n    for (var j = 0; j < comps[i].unknowns.length; j++) {\r\n-%>\r\n        unknowns['<%= comps[i].unknowns[j].name %>'] = <%= comps[i].unknowns[j].name %>\r\n<%\r\n    }\r\n-%>\r\n<%\r\n    // If the component is implicit, generate code for apply_nonlinear()\r\n    if (comps[i].type === 'Implicit') {\r\n        // TODO: Generate statements giving the values for residuals\r\n-%>\r\n\r\n    def apply_nonlinear(self, params, unknowns, resids):\r\n        print \"Provide the values of the residuals in apply_nonlinear() for <%= comps[i].name %>\"\r\n<%\r\n    }\r\n-%>\r\n<%\r\n    // If the force_fd is set to false, generate code for linearize()\r\n    if (comps[i].force_fd === false) {\r\n-%>\r\n\r\n    def linearize(self, params, unknowns, resids):\r\n        J = {}\r\n\r\n        # Assigning shorthand(s) to the parameter(s)\r\n<%\r\n        // Generate statements for dummy implementation of the method\r\n        for (var j = 0; j < comps[i].parameters.length; j++) {\r\n-%>\r\n        <%= comps[i].parameters[j].name %> = params['<%= comps[i].parameters[j].name %>']\r\n<%\r\n        }\r\n-%>\r\n\r\n        # This jecobian is defined by user using the embedded code editor in MOCA\r\n<%\r\n        // Print the user defined code snippet\r\n        var jecobianLines = comps[i].jacobian.split(\"\\n\");\r\n        for (var j = 0; j < jecobianLines.length; j++) {\r\n            if (jecobianLines[j] !== '') {\r\n-%>\r\n        <%- jecobianLines[j] %>\r\n<%\r\n            }\r\n        }\r\n-%>\r\n\r\n        # Return Jacobian (should not be empty)\r\n        return J\r\n<%\r\n    }\r\n-%>\r\n\r\n<%\r\n}\r\n-%>\r\n",
    "moca.groups.generated.py.ejs": "#!/usr/bin/python\r\n\r\n# Static imports\r\nfrom openmdao.api import Group\r\nimport components\r\nimport sys\r\n\r\n# Dynamic imports\r\n<%\r\nfor (var i = 0; i < groups.length; i++) {\r\n    if (groups[i].algebraicLoop) {\r\n-%>\r\nfrom openmdao.api import NLGaussSeidel, ScipyGMRES\r\n<%\r\n        break;\r\n    }\r\n}\r\n-%>\r\n\r\n<%\r\n// Generate the code for all the groups\r\nfor (var i = 0; i < groups.length; i++) {\r\n-%>\r\nclass <%= groups[i].name %>(Group):\r\n    def __init__(self):\r\n        super(<%= groups[i].name %>, self).__init__()\r\n\r\n<%\r\n    // Generate the code for add() statements for components -\r\n    // add instances of components\r\n    for (var j = 0; j < groups[i].compInstances.length; j++) {\r\n        promotesString = '';\r\n        for (var k = 0; k < groups[i].compInstances[j].promotes.length; k++) {\r\n            promotesString += \"'\" + groups[i].compInstances[j].promotes[k] + \"'\";\r\n            if (k != groups[i].compInstances[j].promotes.length - 1)\r\n                promotesString += ', ';\r\n        }\r\n-%>\r\n        self.add('<%= groups[i].compInstances[j].name %>', components.<%= groups[i].compInstances[j].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n    }\r\n-%>\r\n\r\n<%\r\n    // Generate the code for add() statements for groups -\r\n    // add instances of groups\r\n    for (var j = 0; j < groups[i].groupInstances.length; j++) {\r\n        var promotesString = '';\r\n        for (var k = 0; k < groups[i].groupInstances[j].promotes.length; k++) {\r\n            promotesString += \"'\" + groups[i].groupInstances[j].promotes[k] + \"'\";\r\n            if (k != groups[i].groupInstances[j].promotes.length - 1)\r\n                promotesString += ', ';\r\n        }\r\n-%>\r\n        self.add('<%= groups[i].groupInstances[j].name %>', <%= groups[i].groupInstances[j].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n    }\r\n-%>\r\n\r\n<%\r\n    // Generate the code for connect() statements for connections between ports\r\n    for (var j = 0; j < groups[i].connections.length; j++) {\r\n-%>\r\n        self.connect('<%= groups[i].connections[j].srcParent %>.<%= groups[i].connections[j].src %>', '<%= groups[i].connections[j].dstParent %>.<%= groups[i].connections[j].dst %>')\r\n<%\r\n    }\r\n-%>\r\n<%\r\n    // Change nl_solver and ln_driver in case of algebraic loop\r\n    if (groups[i].algebraicLoop) {\r\n-%>\r\n\r\n        # Special solvers for handling algebraic loops\r\n        self.nl_solver = NLGaussSeidel()\r\n        self.nl_solver.options['atol'] = 1.0e-12\r\n        self.ln_solver = ScipyGMRES()\r\n<%\r\n    }\r\n-%>\r\n\r\n<%\r\n}\r\n%>\r\n",
    "moca.parseutils.generated.py.ejs": "__author__ = 'Amogh'\r\n__doc__ = 'The utility class defined in this file gives the methods to access the sqlite database file' \\\r\n          'saved by OpenMDAO sqlite driver.'\r\n\r\nfrom sqlitedict import SqliteDict\r\n\r\nclass SqliteParseUtils:\r\n    def __init__(self, top):\r\n        # Get the database filename.\r\n        self.filename = top.driver.recorders._recorders[0].out.filename\r\n\r\n        # Wait for analysis to finish.\r\n        top.cleanup()\r\n\r\n    def __getValues(self, vartype, name):\r\n        values = []\r\n        db = SqliteDict(self.filename, 'openmdao')\r\n        keylist = db.keys()\r\n        for key in keylist:\r\n            if key != 'metadata':\r\n                data = db[key]\r\n                if vartype != 'timestamp':\r\n                    values.append(data[vartype][name])\r\n                else:\r\n                    values.append(data[vartype])\r\n        return values\r\n\r\n    def getParamValues(self, paramname):\r\n        return self.__getValues('Parameters', paramname)\r\n\r\n    def getUnknownValues(self, unknownname):\r\n        return self.__getValues('Unknowns', unknownname)\r\n\r\n    def getTimestampValues(self):\r\n        return self.__getValues('timestamp', None)\r\n",
    "moca.plotutils.generated.py.ejs": "__author__ = 'Amogh'\r\n__doc__ = 'The utility class defined in this file gives the methods to plot' \\\r\n          'the data points saved in the list on 2D and 3D plots.'\r\n\r\nimport matplotlib.pyplot as plt\r\n\r\nclass PlotUtils:\r\n    def plot2D (self, x_list, y_list, x_lims, y_lims, x_label, y_label):\r\n        plt.plot(x_list, y_list, 'ro')\r\n        plt.xlabel(x_label)\r\n        plt.ylabel(y_label)\r\n        plt.axis([x_lims[0], x_lims[1], y_lims[0], y_lims[1]])\r\n        plt.show()\r\n",
    "moca.problem.generated.ipynb.ejs": "{\r\n \"cells\": [\r\n  {\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"# <%= name %> Notebook\\n\",\r\n      \"***\",\r\n      \"\\n\",\r\n      \"## Instantiation and execution\\n\",\r\n      \"\\n\",\r\n      \"Import the problem.\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"from src.<%= name %> import <%= name %>\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Instantiate the problem.\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"top = <%= name %>()\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Run the problem.\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Assign values to design variable(s).\"\r\n      ,\"\\n\"\r\n<%\r\nfor (var i = 0; i < desvars.length; i++) {\r\n    var valueString = desvars[i].value.toString();\r\n    if (valueString.indexOf('.') === -1) {\r\n        valueString += '.0';\r\n    }\r\n-%>\r\n      ,\"top['<%= desvars[i].name %>.<%= desvars[i].connection[0].dst %>'] = <%= valueString %>\"\r\n      ,\"\\n\"\r\n<%\r\n}\r\n-%>\r\n      ,\"# Execute the problem.\"\r\n      ,\"\\n\"\r\n      ,\"top.run()\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"***\",\r\n      \"\\n\",\r\n      \"## Analysis\\n\"\r\n<%\r\nif (driver === 'ScipyOptimizer') {\r\n-%>\r\n      ,\"\\n\"\r\n      ,\"_**Optimization analysis**_\\n\"\r\n      ,\"\\n\"\r\n      ,\"**Objectives**\"\r\n<%\r\n}\r\n-%>\r\n   ]\r\n  }\r\n<%\r\nif (driver === 'ScipyOptimizer' || driver === 'Default (run once)') {\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Print objectives' values\"\r\n      ,\"\\n\"\r\n<%\r\n    for (var i = 0; i < objectives.length; i++) {\r\n-%>\r\n      ,\"print(\\\"<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %> = %f \\\" % (top['<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>']))\"\r\n<%\r\n        if (i != objectives.length - 1) {\r\n-%>\r\n      ,\"\\n\"\r\n<%\r\n        }\r\n    }\r\n-%>\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"**Design Variables**\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Print design variables' values\"\r\n      ,\"\\n\"\r\n<%\r\n    for (var i = 0; i < desvars.length; i++) {\r\n-%>\r\n      ,\"print(\\\"<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %> = %f\\\" % (top['<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>']))\"\r\n<%\r\n        if (i != desvars.length - 1) {\r\n-%>\r\n      ,\"\\n\"\r\n<%\r\n        }\r\n    }\r\n-%>\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"**Recorded/Monitored variables**\"\r\n   ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n      \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"# Print recorded/monitored variables' values\"\r\n      ,\"\\n\"\r\n<%\r\n    for (var i = 0; i < records.length; i++) {\r\n-%>\r\n      ,\"print(\\\"<%= records[i].connection[0].srcParent %>.<%= records[i].connection[0].src %> = %f\\\" % (top['<%= records[i].connection[0].srcParent %>.<%= records[i].connection[0].src %>']))\"\r\n<%\r\n        if (i != records.length - 1) {\r\n-%>\r\n      ,\"\\n\"\r\n<%\r\n        }\r\n    }\r\n-%>\r\n   ]\r\n  }\r\n<%\r\n} else if (driver === 'FullFactorialDOE' && recorder !== '(None)') {\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"_**Design-of-experiment analysis**_\\n\"\r\n      ,\"\\n\"\r\n      ,\"*Recording*\"\r\n   ]\r\n  }\r\n<%\r\n    if (recorder === 'Dump') {\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"The recorder used is dump recorder, which creates the dumpfile in /out directory.\\n\"\r\n      ,\"It contains all the values of parameters and unknowns in human readable format.\\n\"\r\n    ]\r\n  }\r\n<%\r\n    } else if (recorder === 'Specific') {\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"First, import the parsing utility and initialize it.\\n\"\r\n    ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"from util.MOCAparseutils import SqliteParseUtils\\n\"\r\n      ,\"parseutils = SqliteParseUtils(top)\"\r\n    ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Then, get the list(s) of values which you wanted to record using SqliteParseUtils i.e. -\\n\"\r\n      ,\"\\n\"\r\n      ,\"`getParamValues()`, `getUnknownValues()` or `getTimestampValues()`\"\r\n    ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n<%\r\n        if (records.length > 0) {\r\n            // The following section creates problem if moved into for loop below,\r\n            // because of an extra preceding comma. However, this should only execute\r\n            // if there is at least 1 record in the model.\r\n-%>\r\n      \"<%= records[0].connection[0].srcParent %>_<%= records[0].connection[0].src %>__values = \"\r\n      ,\"parseutils.get<%= records[0].type %>Values('<%= records[0].connection[0].srcParent %>.<%= records[0].connection[0].src %>')\"\r\n      ,\"\\n\"\r\n<%\r\n        }\r\n        for (var i = 1; i < records.length; i++) {\r\n-%>\r\n      ,\"<%= records[i].connection[0].srcParent %>_<%= records[i].connection[0].src %>__values = \"\r\n      ,\"parseutils.get<%= records[i].type %>Values('<%= records[i].connection[0].srcParent %>.<%= records[i].connection[0].src %>')\"\r\n      ,\"\\n\"\r\n<%\r\n        }\r\n        for (var i = 0; i < desvars.length; i++) {\r\n            if (desvars[i].setByDriver) {\r\n-%>\r\n      ,\"<%= desvars[i].connection[0].dstParent %>_<%= desvars[i].connection[0].dst %>__values = \"\r\n      ,\"parseutils.getParamValues('<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>')\"\r\n      ,\"\\n\"\r\n<%\r\n            }\r\n        }\r\n-%>\r\n      ,\"timestamps = parseutils.getTimestampValues()\"\r\n   ]\r\n  }\r\n<%\r\n        if (records.length > 1) {\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"*Visualization*\\n\"\r\n      ,\"\\n\"\r\n      ,\"First, import the plotting utility and initialize it.\"\r\n    ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"code\",\r\n   \"execution_count\": null,\r\n   \"metadata\": {\r\n    \"collapsed\": true\r\n   },\r\n   \"outputs\": [],\r\n   \"source\": [\r\n      \"%matplotlib inline\\n\"\r\n      ,\"from util.MOCAplotutils import PlotUtils\\n\"\r\n      ,\"plotutils = PlotUtils()\"\r\n    ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n      \"Then, configure the plot according to your need.\\n\"\r\n      ,\"\\n\"\r\n      ,\"The parameters which can be configured are - limits and labels of both the axes.\"\r\n    ]\r\n  }\r\n  ,{\r\n    \"cell_type\": \"code\",\r\n    \"execution_count\": null,\r\n    \"metadata\": {\r\n     \"collapsed\": true\r\n    },\r\n    \"outputs\": [],\r\n    \"source\": [\r\n      \"x_axis_values = <%= records[0].connection[0].srcParent %>_<%= records[0].connection[0].src %>__values\\n\"\r\n      ,\"y_axis_values = <%= records[1].connection[0].srcParent %>_<%= records[1].connection[0].src %>__values\\n\"\r\n      ,\"x_axis_limits = [min(x_axis_values), max(x_axis_values)]\\n\"\r\n      ,\"y_axis_limits = [min(y_axis_values), max(y_axis_values)]\\n\"\r\n      ,\"x_axis_label = '<%= records[0].connection[0].srcParent %>.<%= records[0].connection[0].src %>'\\n\"\r\n      ,\"y_axis_label = '<%= records[1].connection[0].srcParent %>.<%= records[1].connection[0].src %>'\"\r\n    ]\r\n  }\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n    \"After configuration, plot the graph.\"\r\n    ]\r\n  }\r\n  ,{\r\n    \"cell_type\": \"code\",\r\n    \"execution_count\": null,\r\n    \"metadata\": {\r\n     \"collapsed\": true\r\n    },\r\n    \"outputs\": [],\r\n    \"source\": [\r\n      \"plotutils.plot2D(x_axis_values, y_axis_values, \"\r\n      ,\"x_axis_limits, y_axis_limits, \"\r\n      ,\"x_axis_label, y_axis_label)\"\r\n    ]\r\n  }\r\n<%\r\n        } // if (records.length > 1) --- If the model has more than 1 record components in the model\r\n    } // if the model has \"specific\" recorder (sqlite)\r\n} else { // if the recorder is neither \"dump\" nor \"specific\"\r\n-%>\r\n  ,{\r\n   \"cell_type\": \"markdown\",\r\n   \"metadata\": {},\r\n   \"source\": [\r\n    \"No recorder selected.\"\r\n   ]\r\n  }\r\n<%\r\n}\r\n-%>\r\n ],\r\n  \"metadata\": {\r\n  \"kernelspec\": {\r\n   \"display_name\": \"Python 2\",\r\n   \"language\": \"python\",\r\n   \"name\": \"python2\"\r\n  },\r\n  \"language_info\": {\r\n   \"codemirror_mode\": {\r\n    \"name\": \"ipython\",\r\n    \"version\": 2\r\n   },\r\n   \"file_extension\": \".py\",\r\n   \"mimetype\": \"text/x-python\",\r\n   \"name\": \"python\",\r\n   \"nbconvert_exporter\": \"python\",\r\n   \"pygments_lexer\": \"ipython2\",\r\n   \"version\": \"2.7.9\"\r\n  }\r\n },\r\n \"nbformat\": 4,\r\n \"nbformat_minor\": 0\r\n}\r\n",
    "moca.problems.generated.py.ejs": "#!/usr/bin/python\r\n\r\n# Static imports\r\nfrom openmdao.api import IndepVarComp, Group, Problem\r\nimport lib.components as components\r\nimport lib.groups as groups\r\n\r\n# Dynamic imports\r\n<%\r\nif (driver === 'ScipyOptimizer') {\r\n-%>\r\nfrom openmdao.api import ScipyOptimizer\r\n<%\r\n} else if (driver === 'FullFactorialDOE') {\r\n-%>\r\nfrom openmdao.api import FullFactorialDriver\r\n<%\r\n}\r\n-%>\r\n<%\r\nif (recorder === 'Dump') {\r\n-%>\r\nfrom openmdao.api import DumpRecorder\r\n<%\r\n} else if (recorder === 'Specific') {\r\n-%>\r\nfrom openmdao.api import SqliteRecorder\r\n<%\r\n}\r\n-%>\r\n<%\r\nif (algebraicLoop) {\r\n-%>\r\nfrom openmdao.api import NLGaussSeidel, ScipyGMRES\r\n<%\r\n}\r\n-%>\r\n\r\nclass RootGroup(Group):\r\n    def __init__(self):\r\n        super(RootGroup, self).__init__()\r\n\r\n<%\r\n// add() statements for design variables\r\nfor (var i = 0; i < desvars.length; i++) {\r\n    var valueString = desvars[i].value.toString();\r\n    if (valueString.indexOf('.') === -1) {\r\n        valueString += '.0';\r\n    }\r\n-%>\r\n        self.add('<%= desvars[i].name %>', IndepVarComp('<%= desvars[i].connection[0].dst %>', <%= valueString %>))\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Generate the code for add() statements for components -\r\n// add instances of components\r\nfor (var j = 0; j < compInstances.length; j++) {\r\n    promotesString = '';\r\n    for (var k = 0; k < compInstances[j].promotes.length; k++) {\r\n        promotesString += \"'\" + compInstances[j].promotes[k] + \"'\";\r\n        if (k != compInstances[j].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= compInstances[j].name %>', components.<%= compInstances[j].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Generate the code for add() statements for groups -\r\n// add instances of groups\r\nfor (var j = 0; j < groupInstances.length; j++) {\r\n    var promotesString = '';\r\n    for (var k = 0; k < groupInstances[j].promotes.length; k++) {\r\n        promotesString += \"'\" + groupInstances[j].promotes[k] + \"'\";\r\n        if (k != groupInstances[j].promotes.length - 1)\r\n            promotesString += ', ';\r\n    }\r\n-%>\r\n        self.add('<%= groupInstances[j].name %>', groups.<%= groupInstances[j].base %>(), promotes=[<%- promotesString %>])\r\n<%\r\n}\r\n-%>\r\n\r\n<%\r\n// Generate the code for connect() statements for connections between ports\r\nfor (var j = 0; j < connections.length; j++) {\r\n-%>\r\n        self.connect('<%= connections[j].srcParent %>.<%= connections[j].src %>', '<%= connections[j].dstParent %>.<%= connections[j].dst %>')\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Generate the code for connect() statements for connections\r\n// between IndepVarComps' ports and ports\r\nfor (var j = 0; j < desvars.length; j++) {\r\n-%>\r\n        self.connect('<%= desvars[j].name %>.<%= desvars[j].connection[0].dst %>', '<%= desvars[j].connection[0].dstParent %>.<%= desvars[j].connection[0].dst %>')\r\n<%\r\n}\r\n-%>\r\n<%\r\n// Change nl_solver and ln_driver in case of algebraic loop\r\nif (algebraicLoop) {\r\n-%>\r\n\r\n        # Special solvers for handling algebraic loops\r\n        self.nl_solver = NLGaussSeidel()\r\n        self.nl_solver.options['atol'] = 1.0e-12\r\n        self.ln_solver = ScipyGMRES()\r\n<%\r\n}\r\n-%>\r\n\r\nclass <%= name %>(Problem):\r\n    def __init__(self):\r\n        super(<%= name %>, self).__init__()\r\n\r\n        self.root = RootGroup()\r\n<%\r\n// Driver settings\r\nif (driver === 'ScipyOptimizer') {\r\n-%>\r\n\r\n        self.driver = ScipyOptimizer()\r\n        self.driver.options['optimizer'] = 'SLSQP'\r\n\r\n<%\r\n    for (var i = 0; i < constraints.length; i++) {\r\n        limitsString = '';\r\n        if (constraints[i].enableUpper) {\r\n            limitsString = 'upper=';\r\n            valueString = constraints[i].upper;\r\n            if (valueString.indexOf('.') === -1)\r\n                valueString += '.0';\r\n            limitsString += valueString;\r\n        }\r\n        if (constraints[i].enableLower) {\r\n            limitsString += ', lower=';\r\n            valueString = constraints[i].lower;\r\n            if (valueString.indexOf('.') === -1)\r\n                valueString += '.0';\r\n            limitsString += valueString;\r\n        }\r\n        if (!constraints[i].enableLower && !constraints[i].enableUpper)\r\n            break;\r\n-%>\r\n        self.driver.add_constraint('<%= constraints[i].connection[0].srcParent %>.<%= constraints[i].connection[0].src %>', <%= limitsString %>)\r\n<%\r\n    }\r\n-%>\r\n<%\r\n} else if (driver === 'FullFactorialDOE') {\r\n-%>\r\n\r\n        self.driver = FullFactorialDriver(<%= doeSamples %>)\r\n<%\r\n}\r\n-%>\r\n<%\r\n// add recorder\r\nif (recorder === 'Dump') {\r\n-%>\r\n\r\n        rec = DumpRecorder('out/<%= name %>_dumpfile')\r\n        rec.options['record_params'] = True\r\n        rec.options['record_unknowns'] = True\r\n        self.driver.add_recorder(rec)\r\n<%\r\n} else if (recorder === 'Specific') {\r\n        var incWord = \"'\" + \"includes\" + \"'\";\r\n        var incString = '';\r\n        for (var i = 0; i < desvars.length; i++) {\r\n            if (desvars[i].setByDriver) {\r\n                // construct incString\r\n                incString += \"'\" + desvars[i].connection[0].dstParent + \".\" + desvars[i].connection[0].dst + \"'\";\r\n                incString += \", \";\r\n            }\r\n        }\r\n        for (var i = 0; i < records.length; i++) {\r\n            // construct incString\r\n            incString += \"'\" + records[i].connection[0].srcParent + \".\" + records[i].connection[0].src + \"'\";\r\n            if (i != records.length - 1)\r\n                incString += \", \";\r\n        }\r\n        if (incString === \"\")\r\n            incString = \"'\" + \"*\" + \"'\";\r\n-%>\r\n\r\n        rec = SqliteRecorder('out/<%= name %>_sqlitefile')\r\n        rec.options['record_params'] = True\r\n        rec.options['record_unknowns'] = True\r\n        rec.options[<%- incWord %>] = [<%- incString %>]\r\n        self.driver.add_recorder(rec)\r\n<%\r\n}\r\n-%>\r\n\r\n<%\r\n// add_desvar() statements for design variables\r\nfor (var i = 0; i < desvars.length; i++) {\r\n    if (desvars[i].setByDriver) {\r\n        var upperString = desvars[i].upper.toString(),\r\n            lowerString = desvars[i].lower.toString();\r\n        if (upperString.indexOf('.') === -1) {\r\n            upperString += '.0';\r\n        }\r\n        if (lowerString.indexOf('.') === -1) {\r\n            lowerString += '.0';\r\n        }\r\n-%>\r\n        self.driver.add_desvar('<%= desvars[i].name %>.<%= desvars[i].connection[0].dst %>', lower=<%= lowerString %>, upper=<%= upperString %>)\r\n<%\r\n    }\r\n}\r\n-%>\r\n<%\r\n// add_objective() statements for objectives\r\nfor (var i = 0; i < objectives.length; i++) {\r\n-%>\r\n        self.driver.add_objective('<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>')\r\n<%\r\n}\r\n-%>\r\n        self.setup()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    top = <%= name %>()\r\n\r\n    print \"Running the MOCA problem <%= name %>\"\r\n\r\n    top.run()\r\n\r\n    print \"Result:\"\r\n    print \"------\"\r\n\r\n<%\r\n// Print result in case of optimizer\r\nif (driver === 'ScipyOptimizer') {\r\n-%>\r\n    print \"\\tObjective(s):\"\r\n    print \"\\t------------\"\r\n<%\r\n    for (var i = 0; i < objectives.length; i++) {\r\n-%>\r\n    print(\"\\t\\t<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %> = %f\" % (top['<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>']))\r\n<%\r\n    }\r\n-%>\r\n    print \"\\tDesign variable(s):\"\r\n    print \"\\t------------------\"\r\n<%\r\n    for (var i = 0; i < desvars.length; i++) {\r\n-%>\r\n    print(\"\\t\\t<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %> = %f\" % (top['<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>']))\r\n<%\r\n    }\r\n} else {\r\n-%>\r\n    print \"The DOE result is written in a file named <%= name %>_dumpfile or <%= name %>_sqlitefile in the parent folder.\"\r\n<%\r\n}\r\n-%>\r\n"
}});