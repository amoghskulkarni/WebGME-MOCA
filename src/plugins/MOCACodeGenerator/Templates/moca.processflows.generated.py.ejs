import simpy

class <%= name %>__SimPy_simulation():
    def __init__(self):
<%
for (var i = 0; i < desInterfaces.length; i++) {
    // if the param / result is a child of the process/buffer itself
    var desInterface = desInterfaces[i];
    if (desInterface.dstGrandParent !== null) {
-%>
        self.<%= desInterface.dstParent %>__<%= desInterface.dstMeta %> = <%= desInterface.dstParent %>__<%= desInterface.dstMeta %>
<%
    } else if (desInterface.dstGrandParent === null) {
-%>
        self.<%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %> = <%= desInterface.dstGrandParent %>__<%= desInterface.dstParent %>__<%= desInterface.dstMeta %>
<%
    }
}
-%>

        # SimPy environment
        self.env = simpy.Environment()

        # Simulation states
        self.simulation_states = {
            'timestamps': [],
<%
for (i = 0; i < buffers.length; i++) {
-%>
            'buff_<%= buffers[i].name %>_usage': [],
<%
}
-%>
        }

        # SimPy process for monitoring simulation
        self.sim_monitor = self.env.process(self.monitor(self.env))

        # SimPy processes for shifts
<%
for (i = 0; i < processes.length; i++) {
-%>
        self.<%= processes[i].name %> = self.env.process(self.<%= processes[i].name %>__shift_controller(self.env))
<%
}
-%>

        # SimPy stores for buffers
<%
for (i = 0; i< buffers.length; i++) {
-%>
        self.<%= buffers[i].name %> = simpy.Store(self.env, capacity=<%= buffers[i].size.value %>)
<%
}
-%>

    # Methods for SimPy processes (for shifts and internal business logic)
<%
for (i = 0; i < processes.length; i++) {
-%>
    def <%= processes[i].name %>__shift_controller(self, simpy_env):
        while True:
            # Start production
            <%= processes[i].name %>_proc = simpy_env.process(self.<%= processes[i].name %>__business_logic(simpy_env))
            yield simpy_env.timeout(<%= processes[i].processShiftOnTime.value %>)

            # Stop production
            <%= processes[i].name %>_proc.interrupt("end_of_shift")
            yield simpy_env.timeout(<%= processes[i].processShiftOffTime.value %>)

    def <%= processes[i].name %>__business_logic(self, simpy_env):
        # A unique item ID needs to be associated with every item to push it into buffers (restriction by SimPy)
        item_id = 0
        while True:
            try:
                # Get the input material (or in case of processes at the start of the chain, don't do anything)
<%
    // Filter every such connection for which this process is dst
    for (var j = 0; j < connections.length; j++) {
        if (connections[j].name == 'BuffToProcFlow' && connections[j].dst == processes[i].name) {
-%>
                yield self.<%= connections[j].src %>.get()
<%
        }
    }
-%>

                # Simulate production
                yield simpy_env.timeout(<%= processes[i].processingTime.value %>)

                # Put the processed material into the buffer (assumption: process is storing the part in only one buffer)
<%
    // Filter the first connection for which this process is src
    for (j = 0; j < connections.length; j++) {
        if (connections[j].name == 'ProcToBuffFlow' && connections[j].src == processes[i].name) {
-%>
                yield self.<%= connections[j].dst %>.put("<%= processes[i].name %>_%s" % item_id)
                item_id += 1
<%
            break;
        }
    }
-%>
            except simpy.Interrupt as i:
                return

<%
}
-%>

    # Method to monitor simulation stats
    def monitor(self, simpy_env):
        while True:
            yield simpy_env.timeout(0.1)
            self.simulation_states['timestamps'].append(simpy_env.now)
<%
for (i = 0; i < buffers.length; i++) {
-%>
            self.simulation_states['buff_<%= buffers[i].name %>_usage'].append(len(self.<%= buffers[i].name %>.items))
<%
}
-%>

    # Method to simulate the SimPy simulation
    def simulate(self):
        self.env.run(until=<%= simend %>)
