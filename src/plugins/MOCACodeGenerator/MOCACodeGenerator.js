/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Mon Feb 01 2016 12:33:01 GMT-0600 (Central Standard Time).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'common/util/ejs',
    'common/util/xmljsonconverter',
    'plugin/MOCACodeGenerator/MOCACodeGenerator/Templates/Templates',
    'q'
], function (
    PluginConfig,
    PluginBase,
    ejs,
    Converter,
    TEMPLATES,
    Q) {
    'use strict';

    /**
     * Initializes a new instance of MOCACodeGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin MOCACodeGenerator.
     * @constructor
     */
    var MOCACodeGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);

        this.LANGUAGES = [
            {
                name: 'Python',
                generated: 'python.generated.py.ejs',
                batFile: 'python.bat.ejs',
                static: 'python.simulator.py.ejs',
                fileExtension: 'py'
            }
        ];
    };

    // Prototypal inheritance from PluginBase.
    MOCACodeGenerator.prototype = Object.create(PluginBase.prototype);
    MOCACodeGenerator.prototype.constructor = MOCACodeGenerator;

    /**
     * Gets the name of the MOCACodeGenerator.
     * @returns {string} The name of the plugin.
     * @public
     */
    MOCACodeGenerator.prototype.getName = function () {
        return 'MOCACodeGenerator';
    };

    /**
     * Gets the semantic version (semver.org) of the MOCACodeGenerator.
     * @returns {string} The version of the plugin.
     * @public
     */
    MOCACodeGenerator.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    MOCACodeGenerator.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject;
        nodeObject = self.activeNode;

        // Using the logger.
//         self.logger.debug('This is a debug message.');
//         self.logger.info('This is an info message.');
//         self.logger.warn('This is a warning message.');
//         self.logger.error('This is an error message.');
        if (self.core.getPath(nodeObject) === '' ||
            self.core.getAttribute(self.getMetaType(nodeObject), 'name') !== 'Problem') {
            callback(new Error('Active node is not a "UMLStateMachine".'), self.result);
            return;
        }

        // Using the coreAPI to make changes.
//         self.core.setAttribute(nodeObject, 'name', 'My new obj');
//         self.core.setRegistry(nodeObject, 'position', {x: 70, y: 70});


        // This will save the changes. If you don't want to save;
        // exclude self.save and call callback directly from this scope.
//         self.save('MOCACodeGenerator updated model.', function (err) {
//             if (err) {
//                 callback(err, self.result);
//                 return;
//             }
//             self.result.setSuccess(true);
//             callback(null, self.result);
//         });

        self.generateDataModel(nodeObject)
            .then(function (dataModel) {
                self.logger.info(JSON.stringify(dataModel, null, 4));
                return self.generateArtifact(dataModel);
            })
            .then(function () {
                self.result.setSuccess(true);
                callback(null, self.result);
            })
            .catch(function (err) {
                self.logger.error(err);
                self.createMessage(null, err.message, 'error');
                self.result.setSuccess(false);
                callback(null, self.result);
            })
            .done();
    };


    MOCACodeGenerator.prototype.generateDataModel = function (problemNode) {
        var self = this,
            deferred = new Q.defer(),
            dataModel = {
                OpenMDAOProblem: {
                    name: self.core.getAttribute(problemNode, 'name'),
                    children: []
                }
            };


        self.core.loadChildren(problemNode, function (err, children) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            var childPromises = [],
                i,
                metaType;

            for (i = 0; i < children.length; i += 1) {
//                 if (self.isMetaTypeOf(children[i], self.META.StateBase) === true) {

//                     statePromises.push(self.getStateData(children[i]));
//                     metaType = self.core.getAttribute(self.getMetaType(children[i]), 'name');

//                     if (metaType === 'Initial') {
//                         dataModel.stateMachine.initialState = self.core.getPath(children[i]);
//                     } else if (metaType === 'End') {
//                         dataModel.stateMachine.finalStates.push(self.core.getPath(children[i]));
//                     }
//                 }
                childPromises.push(self.getChildData(children[i]));
            }

            Q.all(childPromises)
                .then(function (childrenData) {
                    dataModel.OpenMDAOProblem.children = childrenData;
                    deferred.resolve(dataModel);
                })
                .catch(deferred.reject);
        });

        return deferred.promise;
    };


    MOCACodeGenerator.prototype.getChildData = function(childNode) {
        var self = this,
            deferred = new Q.defer(),
            childData = {
                id: self.core.getPath(childNode),
                name: self.core.getAttribute(childNode, 'name'),
                meta: self.core.getAttribute(self.core.getMetaType(childNode), 'name')
            },
            error,
            counter;

        deferred.resolve(childData);

//         function atDestinationState(connection) {

//             return function (err, dstState) {
//                 if (err) {
//                     error = new Error(err);
//                 } else {
//                     stateData.transitions.push({
//                         event: self.core.getAttribute(connection, 'event'),
//                         targetId: self.core.getPath(dstState),
//                         targetName: self.core.getAttribute(dstState, 'name'),
//                     });
//                 }

//                 counter -= 1;
//                 if (counter === 0) {
//                     if (error) {
//                         deferred.reject(error);
//                     } else {
//                         deferred.resolve(stateData);
//                     }
//                 }
//             }
//         }

        // Load all connections going out from the stateNode, i.e. has the stateNode as 'src'.
//         self.core.loadCollection(stateNode, 'src', function (err, connections) {
//             if (err) {
//                 deferred.reject(new Error(err));
//                 return;
//             }
//             var i;
//             counter = connections.length;

//             // For each connection load the destination state.
//             for (i = 0; i < connections.length; i += 1) {
//                 self.core.loadPointer(connections[i], 'dst', atDestinationState(connections[i]));
//             }

//             // Make sure to resolve when there are no connections.
//             if (connections.length === 0) {
//                 deferred.resolve(stateData);
//             }
//         });

        return deferred.promise;
    };


    MOCACodeGenerator.prototype.generateArtifact = function (dataModel) {
        var self = this,
            filesToAdd = {},
            deferred = new Q.defer(),
            artifact = self.blobClient.createArtifact(dataModel.OpenMDAOProblem.name);

        filesToAdd[dataModel.OpenMDAOProblem.name + '.json'] = JSON.stringify(dataModel, null, 2);
        filesToAdd[dataModel.OpenMDAOProblem.name + '_metadata.json'] = JSON.stringify({
            projectId: self.projectId,
            commitHash: self.commitHash,
            branchName: self.branchName,
            timeStamp: (new Date()).toISOString(),
            pluginVersion: self.getVersion()
        }, null, 2);

        self.LANGUAGES.forEach(function (languageInfo) {
            self.addLanguageToFiles(filesToAdd, dataModel, languageInfo);
        });

        artifact.addFiles(filesToAdd, function (err) {
            if (err) {
                deferred.reject(new Error(err));
                return;
            }
            self.blobClient.saveAllArtifacts(function (err, hashes) {
                if (err) {
                    deferred.reject(new Error(err));
                    return;
                }

                self.result.addArtifact(hashes[0]);
                deferred.resolve();
            });
        });

        return deferred.promise;
    };


    MOCACodeGenerator.prototype.addLanguageToFiles = function (filesToAdd, dataModel, languageInfo) {
        var genFileName = 'MOCA-GeneratedCode/' + dataModel.OpenMDAOProblem.name + '.' + languageInfo.fileExtension,
            batFileName = 'MOCA-GeneratedCode/' + dataModel.OpenMDAOProblem.name + '.bat';

        this.logger.debug(genFileName);
        this.logger.debug(batFileName);

        filesToAdd[genFileName] = ejs.render(TEMPLATES[languageInfo.generated], dataModel);
        filesToAdd[batFileName] = ejs.render(TEMPLATES[languageInfo.batFile], dataModel);

        //TODO Add the static files too.
        this.logger.info('Generated files for ', languageInfo.name);

    };


    return MOCACodeGenerator;
});
