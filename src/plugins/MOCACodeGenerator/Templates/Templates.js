/* Generated file based on ejs templates */
define([], function() {
    return {
    "moca.components.generated.py.ejs": "#!/usr/bin/python\nfrom openmdao.api import Component\nimport sys\n\n<%\n// Generate the code for all the components\nfor (var i = 0; i < comps.length; i++) {\n-%>\nclass <%= comps[i].name %>(Component):\n    def __init__(self):\n        super(<%= comps[i].name %>, self).__init__()\n<%\n    // Generate \"add_param\" statements\n    for (var j = 0; j < comps[i].parameters.length; j++) {\n        valueString = comps[i].parameters[j].value;\n        if (valueString.indexOf('.') === -1)\n            valueString += '.0';\n-%>\n        self.add_param('<%= comps[i].parameters[j].name %>', val=<%= comps[i].parameters[j].value %>)\n<%\n    }\n-%>\n<%\n    // Generate \"add_output\" and \"add_state\" statements\n    for (var j = 0; j < comps[i].unknowns.length; j++) {\n        var unknown_type;\n        if (comps[i].unknowns[j].type == 'Output') {\n            unknown_type = 'output';\n        } else {\n            unknown_type = 'state';\n        }\n        valueString = comps[i].unknowns[j].value;\n        if (valueString.indexOf('.') === -1)\n            valueString += '.0';\n-%>\n        self.add_<%= unknown_type %>('<%= comps[i].unknowns[j].name %>', val=<%= comps[i].unknowns[j].value %>)\n<%\n    }\n-%>\n<%\n    // Generate statement configuring force_fd\n    if (comps[i].force_fd === true) {\n-%>\n        # self.fd_options['force_fd'] = True            # For openmdao v1.5.0\n        self.deriv_options['type'] = 'fd'\n<%\n    }\n-%>\n\n    def solve_nonlinear(self, params, unknowns, resids):\n        # Assigning shorthand(s) to the parameter(s)\n<%\n    // Generate statements for dummy implementation of the method\n    for (var j = 0; j < comps[i].parameters.length; j++) {\n-%>\n        <%= comps[i].parameters[j].name %> = params['<%= comps[i].parameters[j].name %>']\n<%\n    }\n-%>\n\n<%\n    // Generate statements to give explicit equation between output(s) and input(s)\n    if (comps[i].outputFunction === '') {\n        // Print the dummy code snippet if the user hasn't given one\n        var dummyStatement = '';\n        for (var j = 0; j < comps[i].parameters.length; j++) {\n            dummyStatement += comps[i].parameters[j].name;\n            if (j != comps[i].parameters.length - 1)\n                dummyStatement += ' + ';\n        }\n        for (var j = 0; j < comps[i].unknowns.length; j++) {\n-%>\n        # Dummy function for the unknown <%= comps[i].unknowns[j].name %>\n        <%= comps[i].unknowns[j].name %> = <%= dummyStatement %>\n<%\n        }\n    } else {\n-%>\n        # This code snippet is defined by user using the embedded code editor in MOCA\n<%\n        // Print the user defined code snippet\n        var eqnLines = comps[i].outputFunction.split(\"\\n\");\n        for (var j = 0; j < eqnLines.length; j++) {\n            if (eqnLines[j] !== '') {\n-%>\n        <%- eqnLines[j] %>\n<%\n            }\n        }\n    }\n-%>\n\n        # Assign the value(s) to unknown(s)\n<%\n    for (var j = 0; j < comps[i].unknowns.length; j++) {\n-%>\n        unknowns['<%= comps[i].unknowns[j].name %>'] = <%= comps[i].unknowns[j].name %>\n<%\n    }\n-%>\n<%\n    // If the component is implicit, generate code for apply_nonlinear()\n    if (comps[i].type === 'Implicit') {\n        // TODO: Generate statements giving the values for residuals\n-%>\n\n    def apply_nonlinear(self, params, unknowns, resids):\n        print \"Provide the values of the residuals in apply_nonlinear() for <%= comps[i].name %>\"\n<%\n    }\n-%>\n<%\n    // If the force_fd is set to false, generate code for linearize()\n    if (comps[i].force_fd === false) {\n-%>\n\n    def linearize(self, params, unknowns, resids):\n        J = {}\n\n        # Assigning shorthand(s) to the parameter(s)\n<%\n        // Generate statements for dummy implementation of the method\n        for (var j = 0; j < comps[i].parameters.length; j++) {\n-%>\n        <%= comps[i].parameters[j].name %> = params['<%= comps[i].parameters[j].name %>']\n<%\n        }\n-%>\n\n        # This jecobian is defined by user using the embedded code editor in MOCA\n<%\n        // Print the user defined code snippet\n        var jecobianLines = comps[i].jacobian.split(\"\\n\");\n        for (var j = 0; j < jecobianLines.length; j++) {\n            if (jecobianLines[j] !== '') {\n-%>\n        <%- jecobianLines[j] %>\n<%\n            }\n        }\n-%>\n\n        # Return Jacobian (should not be empty)\n        return J\n<%\n    }\n-%>\n\n<%\n}\n-%>\n",
    "moca.groups.generated.py.ejs": "#!/usr/bin/python\n\n# Static imports\nfrom openmdao.api import Group\nimport components\nimport sys\n\n# Dynamic imports\n<%\nvar algebraicLoopImport = false;\nfor (var i = 0; i < groups.length; i++) {\n    if (groups[i].algebraicLoop && !algebraicLoopImport) {\n        algebraicLoopImport = true;\n-%>\nfrom openmdao.api import NLGaussSeidel, ScipyGMRES\n<%\n        break;\n    }\n}\n-%>\n\n<%\n// Generate the code for all the groups\nfor (var i = 0; i < groups.length; i++) {\n    var promotedPorts = [];\n-%>\nclass <%= groups[i].name %>(Group):\n    def __init__(self):\n        super(<%= groups[i].name %>, self).__init__()\n\n<%\n    // Generate the code for add() statements for components -\n    // add instances of components\n    for (var j = 0; j < groups[i].compInstances.length; j++) {\n        promotesString = '';\n        for (var k = 0; k < groups[i].compInstances[j].promotes.length; k++) {\n            promotesString += \"'\" + groups[i].compInstances[j].promotes[k] + \"'\";\n            promotedPorts.push(groups[i].compInstances[j].name + \".\" + groups[i].compInstances[j].promotes[k]);\n            if (k != groups[i].compInstances[j].promotes.length - 1)\n                promotesString += ', ';\n        }\n-%>\n        self.add('<%= groups[i].compInstances[j].name %>', components.<%= groups[i].compInstances[j].base %>(), promotes=[<%- promotesString %>])\n<%\n    }\n-%>\n\n<%\n    // Generate the code for add() statements for groups -\n    // add instances of groups\n    for (var j = 0; j < groups[i].groupInstances.length; j++) {\n        var promotesString = '';\n        for (var k = 0; k < groups[i].groupInstances[j].promotes.length; k++) {\n            promotesString += \"'\" + groups[i].groupInstances[j].promotes[k] + \"'\";\n            promotedPorts.push(groups[i].groupInstances[j].name + \".\" + groups[i].groupInstances[j].promotes[k]);\n            if (k != groups[i].groupInstances[j].promotes.length - 1)\n                promotesString += ', ';\n        }\n-%>\n        self.add('<%= groups[i].groupInstances[j].name %>', <%= groups[i].groupInstances[j].base %>(), promotes=[<%- promotesString %>])\n<%\n    }\n-%>\n\n<%\n    // Generate the code for connect() statements for connections between ports\n    for (var j = 0; j < groups[i].connections.length; j++) {\n        var srcConnectString = groups[i].connections[j].srcParent + \".\" + groups[i].connections[j].src;\n        var dstConnectString = groups[i].connections[j].dstParent + \".\" + groups[i].connections[j].dst;\n        // Check whether these strings are in promotedPorts list, i.e. whether these ports are connected\n        if (promotedPorts.indexOf(srcConnectString) != -1)\n            srcConnectString = srcConnectString.split('.')[1];\n        if (promotedPorts.indexOf(dstConnectString) != -1)\n            dstConnectString = dstConnectString.split('.')[1];\n-%>\n        self.connect('<%= srcConnectString %>', '<%= dstConnectString %>')\n<%\n    }\n-%>\n<%\n    // Change nl_solver and ln_driver in case of algebraic loop\n    if (groups[i].algebraicLoop) {\n-%>\n\n        # Special solvers for handling algebraic loops\n        self.nl_solver = NLGaussSeidel()\n        self.nl_solver.options['atol'] = 1.0e-12\n        self.ln_solver = ScipyGMRES()\n<%\n    }\n-%>\n\n<%\n}\n%>\n",
    "moca.parseutils.generated.py.ejs": "__author__ = 'Amogh'\n__doc__ = 'The utility class defined in this file gives the methods to access the sqlite database file' \\\n          'saved by OpenMDAO sqlite driver.'\n\nfrom sqlitedict import SqliteDict\n\nclass SqliteParseUtils:\n    def __init__(self, top):\n        # Get the database filename.\n        self.filename = top.driver.recorders._recorders[0].out_iterations.filename\n\n        # Wait for analysis to finish.\n        top.cleanup()\n\n    def __getValues(self, vartype, name):\n        values = []\n        db = SqliteDict(self.filename, 'iterations')\n        keylist = db.keys()\n        for key in keylist:\n            if key != 'metadata':\n                data = db[key]\n                if vartype != 'timestamp':\n                    values.append(data[vartype][name])\n                else:\n                    values.append(data[vartype])\n        return values\n\n    def getParamValues(self, paramname):\n        return self.__getValues('Parameters', paramname)\n\n    def getUnknownValues(self, unknownname):\n        return self.__getValues('Unknowns', unknownname)\n\n    def getTimestampValues(self):\n        return self.__getValues('timestamp', None)\n",
    "moca.plotutils.generated.py.ejs": "__author__ = 'Amogh'\n__doc__ = 'The utility class defined in this file gives the methods to plot' \\\n          'the data points saved in the list on 2D and 3D plots.'\n\nfrom bokeh.models import ColumnDataSource, HoverTool\nfrom bokeh.plotting import figure, show, output_notebook\n\nfrom ipywidgets import interact\nimport ipywidgets as widgets\n\n<%\nfor (var i = 0; i < problems.length; i++) {\nif (problems[i].driver === 'FullFactorialDOE') {\n-%>\n\nclass <%= problems[i].name %>_PlotUtils:\n    def __init__(self, parseutils):\n        self.timestamps = parseutils.getTimestampValues()\n<%\n    // generate __values statements for all the records connected to Unknowns only\n    for (var j = 0; j < problems[i].records.length; j++) {\n        if (problems[i].records[j].type === \"Unknown\") {\n-%>\n        self.<%= problems[i].records[j].connection[0].srcParent %>_<%= problems[i].records[j].connection[0].src %>__values = parseutils.getUnknownValues('<%= problems[i].records[j].connection[0].srcParent %>.<%= problems[i].records[j].connection[0].src %>')\n<%\n        }\n    }\n    // generate __values statements for all the desvars\n    // all desvars are recorded by default, and we access their values by taking the values of IndepVarComps\n    // Since, all IndepVarComps' outputs are Unknowns, we are using getUnknownValues\n    for (var j = 0; j < problems[i].desvars.length; j++) {\n-%>\n        self.<%= problems[i].desvars[j].connection[0].dstParent %>_<%= problems[i].desvars[j].connection[0].dst %>__values = parseutils.getUnknownValues('<%= problems[i].desvars[j].name %>.<%= problems[i].desvars[j].connection[0].dst %>')\n<%\n    }\n-%>\n        # step calculation\n<%\n    for (var j = 0; j < problems[i].desvars.length; j++) {\n        if (problems[i].desvars[j].setByDriver) {\n-%>\n        <%= problems[i].desvars[j].connection[0].dstParent %>_<%= problems[i].desvars[j].connection[0].dst %>__values__sorted = sorted(self.<%= problems[i].desvars[j].connection[0].dstParent %>_<%= problems[i].desvars[j].connection[0].dst %>__values)\n        self.<%= problems[i].desvars[j].connection[0].dstParent %>_<%= problems[i].desvars[j].connection[0].dst %>__step = <%= problems[i].desvars[j].connection[0].dstParent %>_<%= problems[i].desvars[j].connection[0].dst %>__values__sorted[<%= problems[i].doeSamples %>] - <%= problems[i].desvars[j].connection[0].dstParent %>_<%= problems[i].desvars[j].connection[0].dst %>__values__sorted[0]\n<%\n        }\n    }\n-%>\n\n        # bokeh init\n        output_notebook()\n\n        # axes configuration\n<%\n    for (var j = 0; j < problems[i].desvars.length; j++) {\n        if (problems[i].desvars[j].setByDriver) {\n-%>\n        x_axis_values = self.<%= problems[i].desvars[j].connection[0].dstParent %>_<%= problems[i].desvars[j].connection[0].dst %>__values\n<%\n            break;\n        }\n    }\n-%>\n        y_axis_values = self.<%= problems[i].records[0].connection[0].srcParent %>_<%= problems[i].records[0].connection[0].src %>__values\n\n        # bokeh config\n        self.source = ColumnDataSource(data=dict(x=x_axis_values, y=y_axis_values))\n        self.p = figure(title='<%= problems[i].name %>')\n        self.p.add_tools(HoverTool())\n        self.p.circle(x_axis_values, y_axis_values, size=3, source=self.source, alpha=0.5)\n<%\n    var slider_desvars = [];\n    for (var j = 0; j < problems[i].desvars.length; j++) {\n        if (problems[i].desvars[j].setByDriver) {\n            slider_desvars.push({\n                dstParent: problems[i].desvars[j].connection[0].dstParent,\n                dst: problems[i].desvars[j].connection[0].dst,\n                upper: problems[i].desvars[j].upper,\n                lower: problems[i].desvars[j].lower,\n                value: problems[i].desvars[j].value\n            });\n        }\n    }\n    // This string should include all the desvars for which sliders are to be generated\n    var desvar_function_signature_string = \"\";\n    for (var j = 0; j < slider_desvars.length; j++) {\n        var substring = slider_desvars[j].dst + \"_slider, \" + slider_desvars[j].dst + \"_all\";\n        desvar_function_signature_string += substring;\n        if (j < slider_desvars.length - 1)\n            desvar_function_signature_string += \", \";\n    }\n-%>\n\n    def update(self, x, y, <%= desvar_function_signature_string %>):\n        lists_of_indices = []\n        indices = []\n        x_vals = []\n        y_vals = []\n<%\n    for (var j = 0; j < slider_desvars.length; j++) {\n-%>\n        <%= slider_desvars[j].dst %>_indices = []\n<%\n    }\n-%>\n\n<%\n    // These two statements are for each slider_desvar, which check tick-box for it\n    for (var j = 0; j < slider_desvars.length; j++) {\n-%>\n        if not <%= slider_desvars[j].dst %>_all:\n            <%= slider_desvars[j].dst %>_indices = [i<%= j %> for i<%= j %>, j<%= j %> in enumerate(self.<%= slider_desvars[j].dstParent %>_<%= slider_desvars[j].dst %>__values) if abs(j<%= j %> - <%= slider_desvars[j].dst %>_slider) < 0.00001]\n<%\n    }\n-%>\n\n<%\n    // This string is for for including non-self desvars in list_of_indices\n    var slider_desvars_list_string = \"\";\n    for (var j = 0; j < slider_desvars.length; j++) {\n        slider_desvars_list_string += (slider_desvars[j].dst + \"_indices\");\n        if (j < slider_desvars.length - 1) {\n            slider_desvars_list_string += \", \";\n        }\n    }\n    var x_and_y = ['x', 'y'];\n    for (var k = 0; k < x_and_y.length; k++) {\n        var xy = x_and_y[k];\n        for (var j = 0; j < problems[i].records.length; j++) {\n-%>\n        if <%= xy %> == '<%= problems[i].records[j].connection[0].srcParent %>.<%= problems[i].records[j].connection[0].src %>':\n            <%= xy %>_vals = self.<%= problems[i].records[j].connection[0].srcParent %>_<%= problems[i].records[j].connection[0].src %>__values\n            lists_of_indices = [<%= slider_desvars_list_string %>]\n<%\n    }\n-%>\n<%\n        for (var j = 0; j < slider_desvars.length; j++) {\n            // This string is for for including non-self desvars in list_of_indices\n            var non_self_string = \"\";\n            for (var m = 0; m < slider_desvars.length; m++) {\n                if (j != m) {\n                    non_self_string += (slider_desvars[m].dst + \"_indices\");\n                    if (m < slider_desvars.length - 1) {\n                        non_self_string += \", \";\n                    }\n                }\n            }\n-%>\n        if <%= xy %> == '<%= slider_desvars[j].dstParent %>.<%= slider_desvars[j].dst %>':\n            <%= xy %>_vals = self.<%= slider_desvars[j].dstParent %>_<%= slider_desvars[j].dst %>__values\n            lists_of_indices = [<%= non_self_string %>]\n<%\n        }\n-%>\n\n        for index_list in lists_of_indices:\n            if index_list != []:\n                if indices != []:\n                    indices = list(set(indices).intersection(set(index_list)))\n                else:\n                    indices = index_list\n\n<%\n    }\n-%>\n        if indices != []:\n            x_vals = list(x_vals[i] for i in indices)\n            y_vals = list(y_vals[i] for i in indices)\n\n        self.source.data['x'] = x_vals\n        self.source.data['y'] = y_vals\n        self.source.push_notebook()\n\n    def plot (self):\n        show(self.p)\n<%\n    var options_string = \"\";\n    for (var j = 0; j < problems[i].records.length; j++) {\n        var substring = \"'\" + problems[i].records[j].connection[0].srcParent + '.' + problems[i].records[j].connection[0].src + \"'\";\n        options_string += substring;\n        options_string += \", \";\n    }\n\n    for (var j = 0; j < slider_desvars.length; j++) {\n        var substring = \"'\" + slider_desvars[j].dstParent + '.' + slider_desvars[j].dst + \"'\";\n        options_string += substring;\n        if (j < slider_desvars.length - 1) {\n            options_string += \", \";\n        }\n    }\n-%>\n\n    def show_widgets(self):\n        options = [<%- options_string %>]\n        interact(self.update,\n            x=widgets.Dropdown(options=options,value=options[0],description='domain'),\n            y=widgets.Dropdown(options=options,value=options[1],description='range'),\n<%\n    for (var j = 0; j < slider_desvars.length; j++) {\n        var trailing_character;\n        if (j < slider_desvars.length - 1)\n            trailing_character = \",\";\n        else\n            trailing_character = \")\";\n-%>\n            <%= slider_desvars[j].dst %>_slider=widgets.FloatSlider(value=<%= slider_desvars[j].value %>, min=<%= slider_desvars[j].lower %>, max=<%= slider_desvars[j].upper %>, step=self.<%= slider_desvars[j].dstParent %>_<%= slider_desvars[j].dst %>__step, description='<%= slider_desvars[j].dstParent %>.<%= slider_desvars[j].dst %>'),\n            <%= slider_desvars[j].dst %>_all=widgets.Checkbox(description='<%= slider_desvars[j].dstParent %>.<%= slider_desvars[j].dst %> (all values)', value=True)<%= trailing_character %>\n<%\n    }\n}\n}\n-%>",
    "moca.problem.generated.ipynb.ejs": "{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"# <%= name %> Notebook\\n\",\n      \"***\",\n      \"\\n\",\n      \"## Instantiation and execution\\n\",\n      \"\\n\",\n      \"Import the problem.\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"from src.<%= name %> import <%= name %>\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"Instantiate the problem.\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"top = <%= name %>()\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"Run the problem.\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"# Assign values to design variable(s).\"\n      ,\"\\n\"\n<%\nfor (var i = 0; i < desvars.length; i++) {\n    var valueString = desvars[i].value.toString();\n    if (valueString.indexOf('.') === -1) {\n        valueString += '.0';\n    }\n-%>\n      ,\"top['<%= desvars[i].name %>.<%= desvars[i].connection[0].dst %>'] = <%= valueString %>\"\n      ,\"\\n\"\n<%\n}\n-%>\n      ,\"# Execute the problem.\"\n      ,\"\\n\"\n      ,\"top.run()\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"***\",\n      \"\\n\",\n      \"## Analysis\\n\"\n<%\nif (driver === 'ScipyOptimizer') {\n-%>\n      ,\"\\n\"\n      ,\"_**Optimization analysis**_\\n\"\n      ,\"\\n\"\n      ,\"**Objectives**\"\n<%\n}\n-%>\n   ]\n  }\n<%\nif (driver === 'ScipyOptimizer' || driver === 'Default (run once)') {\n    if (driver === 'ScipyOptimizer') {\n-%>\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"# Print objectives' values\"\n      ,\"\\n\"\n<%\n        for (var i = 0; i < objectives.length; i++) {\n-%>\n      ,\"print(\\\"<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %> = %f \\\" % (top['<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>']))\"\n<%\n            if (i != objectives.length - 1) {\n-%>\n      ,\"\\n\"\n<%\n            }\n        }\n-%>\n   ]\n  }\n<%\n    }\n-%>\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"**Design Variables**\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"# Print design variables' values\"\n      ,\"\\n\"\n<%\n    for (var i = 0; i < desvars.length; i++) {\n-%>\n      ,\"print(\\\"<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %> = %f\\\" % (top['<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>']))\"\n<%\n        if (i != desvars.length - 1) {\n-%>\n      ,\"\\n\"\n<%\n        }\n    }\n-%>\n   ]\n  }\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"**Recorded/Monitored variables**\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n      \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"# Print recorded/monitored variables' values\"\n      ,\"\\n\"\n<%\n    for (var i = 0; i < records.length; i++) {\n-%>\n      ,\"print(\\\"<%= records[i].connection[0].srcParent %>.<%= records[i].connection[0].src %> = %f\\\" % (top['<%= records[i].connection[0].srcParent %>.<%= records[i].connection[0].src %>']))\"\n<%\n        if (i != records.length - 1) {\n-%>\n      ,\"\\n\"\n<%\n        }\n    }\n-%>\n   ]\n  }\n<%\n} else if (driver === 'FullFactorialDOE' && recorder !== '(None)') {\n-%>\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"_**Design-of-experiment analysis**_\\n\"\n      ,\"\\n\"\n      ,\"*Recording*\"\n   ]\n  }\n<%\n    if (recorder === 'Dump') {\n-%>\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"The recorder used is dump recorder, which creates the dumpfile in /out directory.\\n\"\n      ,\"It contains all the values of parameters and unknowns in human readable format.\\n\"\n    ]\n  }\n<%\n    } else if (recorder === 'Specific') {\n-%>\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"Import the parsing utility and initialize it.\\n\"\n    ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"from utils.MOCAparseutils import SqliteParseUtils\\n\"\n      ,\"parseutils = SqliteParseUtils(top)\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"Then, import the plotting utilities using the initialized parsing utilities.\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n      \"from utils.MOCAplotutils import <%= name %>_PlotUtils\\n\",\n      \"plotutils = <%= name %>_PlotUtils(parseutils)\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n      \"After importing, use the utils to plot the graph.\"\n    ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"plotutils.plot()\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"After plotting, use the widgets to interact with the plot.\"\n   ]\n  }\n  ,{\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"metadata\": {\n    \"collapsed\": true\n   },\n   \"outputs\": [],\n   \"source\": [\n    \"plotutils.show_widgets()\"\n   ]\n  }\n<%\n    } // if the model has \"specific\" recorder (sqlite)\n} else { // if the recorder is neither \"dump\" nor \"specific\"\n-%>\n  ,{\n   \"cell_type\": \"markdown\",\n   \"metadata\": {},\n   \"source\": [\n    \"No recorder selected.\"\n   ]\n  }\n<%\n}\n-%>\n ],\n  \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 2\",\n   \"language\": \"python\",\n   \"name\": \"python2\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 2\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython2\",\n   \"version\": \"2.7.9\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 0\n}\n",
    "moca.problems.generated.py.ejs": "#!/usr/bin/python\n\n# Static imports\nfrom openmdao.api import IndepVarComp, Group, Problem\nimport lib.components as components\nimport lib.groups as groups\n\n# Dynamic imports\n<%\nif (driver === 'ScipyOptimizer') {\n-%>\nfrom openmdao.api import ScipyOptimizer\n<%\n} else if (driver === 'FullFactorialDOE') {\n-%>\nfrom openmdao.api import FullFactorialDriver\n<%\n}\n-%>\n<%\nif (recorder === 'Dump') {\n-%>\nfrom openmdao.api import DumpRecorder\n<%\n} else if (recorder === 'Specific') {\n-%>\nfrom openmdao.api import SqliteRecorder\n<%\n}\n-%>\n<%\nif (algebraicLoop) {\n-%>\nfrom openmdao.api import NLGaussSeidel, ScipyGMRES\n<%\n}\n-%>\n\nclass RootGroup(Group):\n    def __init__(self):\n        super(RootGroup, self).__init__()\n\n<%\n// add() statements for design variables\nfor (var i = 0; i < desvars.length; i++) {\n    var valueString = desvars[i].value.toString();\n    if (valueString.indexOf('.') === -1) {\n        valueString += '.0';\n    }\n-%>\n        self.add('<%= desvars[i].name %>', IndepVarComp('<%= desvars[i].connection[0].dst %>', <%= valueString %>))\n<%\n}\n-%>\n<%\n// Generate the code for add() statements for components -\n// add instances of components\nfor (var j = 0; j < compInstances.length; j++) {\n    promotesString = '';\n    for (var k = 0; k < compInstances[j].promotes.length; k++) {\n        promotesString += \"'\" + compInstances[j].promotes[k] + \"'\";\n        if (k != compInstances[j].promotes.length - 1)\n            promotesString += ', ';\n    }\n-%>\n        self.add('<%= compInstances[j].name %>', components.<%= compInstances[j].base %>(), promotes=[<%- promotesString %>])\n<%\n}\n-%>\n<%\n// Generate the code for add() statements for groups -\n// add instances of groups\nfor (var j = 0; j < groupInstances.length; j++) {\n    var promotesString = '';\n    for (var k = 0; k < groupInstances[j].promotes.length; k++) {\n        promotesString += \"'\" + groupInstances[j].promotes[k] + \"'\";\n        if (k != groupInstances[j].promotes.length - 1)\n            promotesString += ', ';\n    }\n-%>\n        self.add('<%= groupInstances[j].name %>', groups.<%= groupInstances[j].base %>(), promotes=[<%- promotesString %>])\n<%\n}\n-%>\n\n<%\n// Generate the code for connect() statements for connections between ports\nfor (var j = 0; j < connections.length; j++) {\n-%>\n        self.connect('<%= connections[j].srcParent %>.<%= connections[j].src %>', '<%= connections[j].dstParent %>.<%= connections[j].dst %>')\n<%\n}\n-%>\n<%\n// Generate the code for connect() statements for connections\n// between IndepVarComps' ports and ports\nfor (var j = 0; j < desvars.length; j++) {\n-%>\n        self.connect('<%= desvars[j].name %>.<%= desvars[j].connection[0].dst %>', '<%= desvars[j].connection[0].dstParent %>.<%= desvars[j].connection[0].dst %>')\n<%\n}\n-%>\n<%\n// Change nl_solver and ln_driver in case of algebraic loop\nif (algebraicLoop) {\n-%>\n\n        # Special solvers for handling algebraic loops\n        self.nl_solver = NLGaussSeidel()\n        self.nl_solver.options['atol'] = 1.0e-12\n        self.ln_solver = ScipyGMRES()\n<%\n}\n-%>\n\nclass <%= name %>(Problem):\n    def __init__(self):\n        super(<%= name %>, self).__init__()\n\n        self.root = RootGroup()\n<%\n// Driver settings\nif (driver === 'ScipyOptimizer') {\n-%>\n\n        self.driver = ScipyOptimizer()\n        self.driver.options['optimizer'] = 'SLSQP'\n\n<%\n    for (var i = 0; i < constraints.length; i++) {\n        limitsString = '';\n        if (constraints[i].enableUpper) {\n            limitsString = 'upper=';\n            valueString = constraints[i].upper;\n            if (valueString.indexOf('.') === -1)\n                valueString += '.0';\n            limitsString += valueString;\n        }\n        if (constraints[i].enableLower) {\n            limitsString += ', lower=';\n            valueString = constraints[i].lower;\n            if (valueString.indexOf('.') === -1)\n                valueString += '.0';\n            limitsString += valueString;\n        }\n        if (!constraints[i].enableLower && !constraints[i].enableUpper)\n            break;\n-%>\n        self.driver.add_constraint('<%= constraints[i].connection[0].srcParent %>.<%= constraints[i].connection[0].src %>', <%= limitsString %>)\n<%\n    }\n-%>\n<%\n} else if (driver === 'FullFactorialDOE') {\n-%>\n\n        self.driver = FullFactorialDriver(<%= doeSamples %>)\n<%\n}\n-%>\n<%\n// add recorder\nif (recorder === 'Dump') {\n-%>\n\n        rec = DumpRecorder('out/<%= name %>_dumpfile')\n        rec.options['record_params'] = True\n        rec.options['record_metadata'] = True\n        self.driver.add_recorder(rec)\n<%\n} else if (recorder === 'Specific') {\n//        var incWord = \"'\" + \"includes\" + \"'\";\n//        var incString = '';\n//        for (var i = 0; i < desvars.length; i++) {\n//            if (desvars[i].setByDriver) {\n//                // construct incString\n//                incString += \"'\" + desvars[i].connection[0].dstParent + \".\" + desvars[i].connection[0].dst + \"'\";\n//                incString += \", \";\n//            }\n//        }\n//        for (var i = 0; i < records.length; i++) {\n//            // construct incString\n//            incString += \"'\" + records[i].connection[0].srcParent + \".\" + records[i].connection[0].src + \"'\";\n//            if (i != records.length - 1)\n//                incString += \", \";\n//        }\n//        if (incString === \"\")\n//            incString = \"'\" + \"*\" + \"'\";\n\n//        Add this to the generated code block if the above code is to be uncommented\n//        rec.options[ %= incWord % ] = [ %= incString % ]\n-%>\n\n        rec = SqliteRecorder('out/<%= name %>_sqlitefile')\n        rec.options['record_params'] = True\n        rec.options['record_metadata'] = True\n        self.driver.add_recorder(rec)\n<%\n}\n-%>\n\n<%\n// add_desvar() statements for design variables\nfor (var i = 0; i < desvars.length; i++) {\n    if (desvars[i].setByDriver) {\n        var upperString = desvars[i].upper.toString(),\n            lowerString = desvars[i].lower.toString();\n        if (upperString.indexOf('.') === -1) {\n            upperString += '.0';\n        }\n        if (lowerString.indexOf('.') === -1) {\n            lowerString += '.0';\n        }\n-%>\n        self.driver.add_desvar('<%= desvars[i].name %>.<%= desvars[i].connection[0].dst %>', lower=<%= lowerString %>, upper=<%= upperString %>)\n<%\n    }\n}\n-%>\n<%\n// add_objective() statements for objectives\nfor (var i = 0; i < objectives.length; i++) {\n-%>\n        self.driver.add_objective('<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>')\n<%\n}\n-%>\n        self.setup()\n\n\nif __name__ == \"__main__\":\n\n    top = <%= name %>()\n\n    print \"Running the MOCA problem <%= name %>\"\n\n    top.run()\n\n    print \"Result:\"\n    print \"------\"\n\n<%\n// Print result in case of optimizer\nif (driver === 'ScipyOptimizer') {\n-%>\n    print \"\\tObjective(s):\"\n    print \"\\t------------\"\n<%\n    for (var i = 0; i < objectives.length; i++) {\n-%>\n    print(\"\\t\\t<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %> = %f\" % (top['<%= objectives[i].connection[0].srcParent %>.<%= objectives[i].connection[0].src %>']))\n<%\n    }\n-%>\n    print \"\\tDesign variable(s):\"\n    print \"\\t------------------\"\n<%\n    for (var i = 0; i < desvars.length; i++) {\n-%>\n    print(\"\\t\\t<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %> = %f\" % (top['<%= desvars[i].connection[0].dstParent %>.<%= desvars[i].connection[0].dst %>']))\n<%\n    }\n} else {\n-%>\n    print \"The DOE result is written in a file named <%= name %>_dumpfile or <%= name %>_sqlitefile in the parent folder.\"\n<%\n}\n-%>\n"
}});